{"remainingRequest":"D:\\InformXUI\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--8-1!D:\\InformXUI\\node_modules\\@okta\\okta-auth-js\\lib\\tx.js","dependencies":[{"path":"D:\\InformXUI\\node_modules\\@okta\\okta-auth-js\\lib\\tx.js","mtime":1561962764641},{"path":"D:\\InformXUI\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1561962767981},{"path":"D:\\InformXUI\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1561962756102}],"contextDependencies":[],"result":["/*!\r\n * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.\r\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\r\n *\r\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n *\r\n * See the License for the specific language governing permissions and limitations under the License.\r\n *\r\n */\r\n\r\n/* eslint-disable complexity, max-statements */\r\nvar http              = require('./http');\r\nvar util              = require('./util');\r\nvar Q                 = require('q');\r\nvar AuthSdkError      = require('./errors/AuthSdkError');\r\nvar AuthPollStopError = require('./errors/AuthPollStopError');\r\nvar config            = require('./config');\r\n\r\nfunction addStateToken(res, options) {\r\n  var builtArgs = {};\r\n  util.extend(builtArgs, options);\r\n\r\n  // Add the stateToken if one isn't passed and we have one\r\n  if (!builtArgs.stateToken && res.stateToken) {\r\n    builtArgs.stateToken = res.stateToken;\r\n  }\r\n\r\n  return builtArgs;\r\n}\r\n\r\nfunction getStateToken(res) {\r\n  return addStateToken(res);\r\n}\r\n\r\nfunction transactionStatus(sdk, args) {\r\n  args = addStateToken(sdk, args);\r\n  return http.post(sdk, sdk.options.url + '/api/v1/authn', args);\r\n}\r\n\r\nfunction resumeTransaction(sdk, args) {\r\n  if (!args || !args.stateToken) {\r\n    var stateToken = sdk.tx.exists._get(config.STATE_TOKEN_KEY_NAME);\r\n    if (stateToken) {\r\n      args = {\r\n        stateToken: stateToken\r\n      };\r\n    } else {\r\n      return Q.reject(new AuthSdkError('No transaction to resume'));\r\n    }\r\n  }\r\n  return sdk.tx.status(args)\r\n    .then(function(res) {\r\n      return new AuthTransaction(sdk, res);\r\n    });\r\n}\r\n\r\nfunction transactionExists(sdk) {\r\n  // We have a cookie state token\r\n  return !!sdk.tx.exists._get(config.STATE_TOKEN_KEY_NAME);\r\n}\r\n\r\nfunction postToTransaction(sdk, url, args, options) {\r\n  return http.post(sdk, url, args, options)\r\n    .then(function(res) {\r\n      return new AuthTransaction(sdk, res);\r\n    });\r\n}\r\n\r\nfunction getPollFn(sdk, res, ref) {\r\n  return function (options) {\r\n    var delay;\r\n    var rememberDevice;\r\n    var autoPush;\r\n\r\n    if (util.isNumber(options)) {\r\n      delay = options;\r\n    } else if (util.isObject(options)) {\r\n      delay = options.delay;\r\n      rememberDevice = options.rememberDevice;\r\n      autoPush = options.autoPush;\r\n    }\r\n\r\n    if (!delay && delay !== 0) {\r\n      delay = config.DEFAULT_POLLING_DELAY;\r\n    }\r\n\r\n    // Get the poll function\r\n    var pollLink = util.getLink(res, 'next', 'poll');\r\n    function pollFn() {\r\n      var opts = {};\r\n      if (typeof autoPush === 'function') {\r\n        try {\r\n          opts.autoPush = !!autoPush();\r\n        }\r\n        catch (e) {\r\n          return Q.reject(new AuthSdkError('AutoPush resulted in an error.'));\r\n        }\r\n      }\r\n      else if (autoPush !== undefined && autoPush !== null) {\r\n        opts.autoPush = !!autoPush;\r\n      }\r\n      if (typeof rememberDevice === 'function') {\r\n        try {\r\n          opts.rememberDevice = !!rememberDevice();\r\n        }\r\n        catch (e) {\r\n          return Q.reject(new AuthSdkError('RememberDevice resulted in an error.'));\r\n        }\r\n      }\r\n      else if (rememberDevice !== undefined && rememberDevice !== null) {\r\n        opts.rememberDevice = !!rememberDevice;\r\n      }\r\n\r\n      var href = pollLink.href + util.toQueryParams(opts);\r\n      return http.post(sdk, href, getStateToken(res), {\r\n        saveAuthnState: false  \r\n      });\r\n    }\r\n\r\n    ref.isPolling = true;\r\n\r\n    var retryCount = 0;\r\n    var recursivePoll = function () {\r\n      // If the poll was manually stopped during the delay\r\n      if (!ref.isPolling) {\r\n        return Q.reject(new AuthPollStopError());\r\n      }\r\n      return pollFn()\r\n        .then(function (pollRes) {\r\n          // Reset our retry counter on success\r\n          retryCount = 0;\r\n\r\n          // If we're still waiting\r\n          if (pollRes.factorResult && pollRes.factorResult === 'WAITING') {\r\n\r\n            // If the poll was manually stopped while the pollFn was called\r\n            if (!ref.isPolling) {\r\n              throw new AuthPollStopError();\r\n            }\r\n\r\n            // Continue poll\r\n            return Q.delay(delay)\r\n              .then(recursivePoll);\r\n\r\n          } else {\r\n            // Any non-waiting result, even if polling was stopped\r\n            // during a request, will return\r\n            ref.isPolling = false;\r\n            return new AuthTransaction(sdk, pollRes);\r\n          }\r\n        })\r\n        .fail(function(err) {\r\n          // Exponential backoff, up to 16 seconds\r\n          if (err.xhr &&\r\n              (err.xhr.status === 0 || err.xhr.status === 429) &&\r\n              retryCount <= 4) {\r\n            var delayLength = Math.pow(2, retryCount) * 1000;\r\n            retryCount++;\r\n            return Q.delay(delayLength)\r\n              .then(recursivePoll);\r\n          }\r\n          throw err;\r\n        });\r\n    };\r\n    return recursivePoll()\r\n      .fail(function(err) {\r\n        ref.isPolling = false;\r\n        throw err;\r\n      });\r\n  };\r\n}\r\n\r\nfunction link2fn(sdk, res, obj, link, ref) {\r\n  if (Array.isArray(link)) {\r\n    return function(name, opts) {\r\n      if (!name) {\r\n        throw new AuthSdkError('Must provide a link name');\r\n      }\r\n\r\n      var lk = util.find(link, {name: name});\r\n      if (!lk) {\r\n        throw new AuthSdkError('No link found for that name');\r\n      }\r\n\r\n      return link2fn(sdk, res, obj, lk, ref)(opts);\r\n    };\r\n\r\n  } else if (link.hints &&\r\n      link.hints.allow &&\r\n      link.hints.allow.length === 1) {\r\n    var method = link.hints.allow[0];\r\n    switch (method) {\r\n\r\n      case 'GET':\r\n        return function() {\r\n          return http.get(sdk, link.href);\r\n        };\r\n\r\n      case 'POST':\r\n        return function(opts) {\r\n          if (ref && ref.isPolling) {\r\n            ref.isPolling = false;\r\n          }\r\n\r\n          var data = addStateToken(res, opts);\r\n\r\n          if (res.status === 'MFA_ENROLL') {\r\n            // Add factorType and provider\r\n            util.extend(data, {\r\n              factorType: obj.factorType,\r\n              provider: obj.provider\r\n            });\r\n          }\r\n\r\n          var params = {};\r\n          var autoPush = data.autoPush;\r\n          if (autoPush !== undefined) {\r\n            if (typeof autoPush === 'function') {\r\n              try {\r\n                params.autoPush = !!autoPush();\r\n              }\r\n              catch (e) {\r\n                return Q.reject(new AuthSdkError('AutoPush resulted in an error.'));\r\n              }\r\n            }\r\n            else if (autoPush !== null) {\r\n              params.autoPush = !!autoPush;\r\n            }\r\n            data = util.omit(data, 'autoPush');\r\n          }\r\n\r\n          var rememberDevice = data.rememberDevice;\r\n          if (rememberDevice !== undefined) {\r\n            if (typeof rememberDevice === 'function') {\r\n              try {\r\n                params.rememberDevice = !!rememberDevice();\r\n              }\r\n              catch (e) {\r\n                return Q.reject(new AuthSdkError('RememberDevice resulted in an error.'));\r\n              }\r\n            }\r\n            else if (rememberDevice !== null) {\r\n              params.rememberDevice = !!rememberDevice;\r\n            }\r\n            data = util.omit(data, 'rememberDevice');\r\n\r\n          } else if (data.profile &&\r\n                    data.profile.updatePhone !== undefined) {\r\n            if (data.profile.updatePhone) {\r\n              params.updatePhone = true;\r\n            }\r\n            data.profile = util.omit(data.profile, 'updatePhone');\r\n          }\r\n          var href = link.href + util.toQueryParams(params);\r\n          return postToTransaction(sdk, href, data);\r\n        };\r\n    }\r\n  }\r\n}\r\n\r\nfunction links2fns(sdk, res, obj, ref) {\r\n  var fns = {};\r\n  for (var linkName in obj._links) {\r\n    if (!obj._links.hasOwnProperty(linkName)) {\r\n      continue;\r\n    }\r\n\r\n    var link = obj._links[linkName];\r\n    \r\n    if (linkName === 'next') {\r\n      linkName = link.name;\r\n    }\r\n\r\n    if (link.type) {\r\n      fns[linkName] = link;\r\n      continue;\r\n    }\r\n\r\n    switch (linkName) {\r\n      // poll is only found at the transaction\r\n      // level, so we don't need to pass the link\r\n      case 'poll':\r\n        fns.poll = getPollFn(sdk, res, ref);\r\n        break;\r\n\r\n      default:\r\n        var fn = link2fn(sdk, res, obj, link, ref);\r\n        if (fn) {\r\n          fns[linkName] = fn;\r\n        }\r\n    }\r\n  }\r\n  return fns;\r\n}\r\n\r\nfunction flattenEmbedded(sdk, res, obj, ref) {\r\n  obj = obj || res;\r\n  obj = util.clone(obj);\r\n\r\n  if (Array.isArray(obj)) {\r\n    var objArr = [];\r\n    for (var o = 0, ol = obj.length; o < ol; o++) {\r\n      objArr.push(flattenEmbedded(sdk, res, obj[o], ref));\r\n    }\r\n    return objArr;\r\n  }\r\n\r\n  var embedded = obj._embedded || {};\r\n\r\n  for (var key in embedded) {\r\n    if (!embedded.hasOwnProperty(key)) {\r\n      continue;\r\n    }\r\n\r\n    // Flatten any nested _embedded objects\r\n    if (util.isObject(embedded[key]) || Array.isArray(embedded[key])) {\r\n      embedded[key] = flattenEmbedded(sdk, res, embedded[key], ref);\r\n    }\r\n  }\r\n\r\n  // Convert any links on the embedded object\r\n  var fns = links2fns(sdk, res, obj, ref);\r\n  util.extend(embedded, fns);\r\n\r\n  obj = util.omit(obj, '_embedded', '_links');\r\n  util.extend(obj, embedded);\r\n  return obj;\r\n}\r\n\r\nfunction AuthTransaction(sdk, res) {\r\n  if (res) {\r\n    this.data = res;\r\n    util.extend(this, flattenEmbedded(sdk, res, res, {}));\r\n    delete this.stateToken;\r\n\r\n    // RECOVERY_CHALLENGE has some responses without _links.\r\n    // Without _links, we emulate cancel to make it intuitive\r\n    // to return to the starting state. We may remove this\r\n    // when OKTA-75434 is resolved\r\n    if (res.status === 'RECOVERY_CHALLENGE' && !res._links) {\r\n      this.cancel = function() {\r\n        return new Q(new AuthTransaction(sdk));\r\n      };\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = {\r\n  transactionStatus: transactionStatus,\r\n  resumeTransaction: resumeTransaction,\r\n  transactionExists: transactionExists,\r\n  postToTransaction: postToTransaction\r\n};\r\n",null]}