{"remainingRequest":"D:\\ISG-InformX\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--8-1!D:\\ISG-InformX\\node_modules\\d3-voronoi\\src\\Cell.js","dependencies":[{"path":"D:\\ISG-InformX\\node_modules\\d3-voronoi\\src\\Cell.js","mtime":1562860465463},{"path":"D:\\ISG-InformX\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1562860456543},{"path":"D:\\ISG-InformX\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1562860430677}],"contextDependencies":[],"result":["import {createBorderEdge} from \"./Edge\";\r\nimport {cells, edges, epsilon} from \"./Diagram\";\r\n\r\nexport function createCell(site) {\r\n  return cells[site.index] = {\r\n    site: site,\r\n    halfedges: []\r\n  };\r\n}\r\n\r\nfunction cellHalfedgeAngle(cell, edge) {\r\n  var site = cell.site,\r\n      va = edge.left,\r\n      vb = edge.right;\r\n  if (site === vb) vb = va, va = site;\r\n  if (vb) return Math.atan2(vb[1] - va[1], vb[0] - va[0]);\r\n  if (site === va) va = edge[1], vb = edge[0];\r\n  else va = edge[0], vb = edge[1];\r\n  return Math.atan2(va[0] - vb[0], vb[1] - va[1]);\r\n}\r\n\r\nexport function cellHalfedgeStart(cell, edge) {\r\n  return edge[+(edge.left !== cell.site)];\r\n}\r\n\r\nexport function cellHalfedgeEnd(cell, edge) {\r\n  return edge[+(edge.left === cell.site)];\r\n}\r\n\r\nexport function sortCellHalfedges() {\r\n  for (var i = 0, n = cells.length, cell, halfedges, j, m; i < n; ++i) {\r\n    if ((cell = cells[i]) && (m = (halfedges = cell.halfedges).length)) {\r\n      var index = new Array(m),\r\n          array = new Array(m);\r\n      for (j = 0; j < m; ++j) index[j] = j, array[j] = cellHalfedgeAngle(cell, edges[halfedges[j]]);\r\n      index.sort(function(i, j) { return array[j] - array[i]; });\r\n      for (j = 0; j < m; ++j) array[j] = halfedges[index[j]];\r\n      for (j = 0; j < m; ++j) halfedges[j] = array[j];\r\n    }\r\n  }\r\n}\r\n\r\nexport function clipCells(x0, y0, x1, y1) {\r\n  var nCells = cells.length,\r\n      iCell,\r\n      cell,\r\n      site,\r\n      iHalfedge,\r\n      halfedges,\r\n      nHalfedges,\r\n      start,\r\n      startX,\r\n      startY,\r\n      end,\r\n      endX,\r\n      endY,\r\n      cover = true;\r\n\r\n  for (iCell = 0; iCell < nCells; ++iCell) {\r\n    if (cell = cells[iCell]) {\r\n      site = cell.site;\r\n      halfedges = cell.halfedges;\r\n      iHalfedge = halfedges.length;\r\n\r\n      // Remove any dangling clipped edges.\r\n      while (iHalfedge--) {\r\n        if (!edges[halfedges[iHalfedge]]) {\r\n          halfedges.splice(iHalfedge, 1);\r\n        }\r\n      }\r\n\r\n      // Insert any border edges as necessary.\r\n      iHalfedge = 0, nHalfedges = halfedges.length;\r\n      while (iHalfedge < nHalfedges) {\r\n        end = cellHalfedgeEnd(cell, edges[halfedges[iHalfedge]]), endX = end[0], endY = end[1];\r\n        start = cellHalfedgeStart(cell, edges[halfedges[++iHalfedge % nHalfedges]]), startX = start[0], startY = start[1];\r\n        if (Math.abs(endX - startX) > epsilon || Math.abs(endY - startY) > epsilon) {\r\n          halfedges.splice(iHalfedge, 0, edges.push(createBorderEdge(site, end,\r\n              Math.abs(endX - x0) < epsilon && y1 - endY > epsilon ? [x0, Math.abs(startX - x0) < epsilon ? startY : y1]\r\n              : Math.abs(endY - y1) < epsilon && x1 - endX > epsilon ? [Math.abs(startY - y1) < epsilon ? startX : x1, y1]\r\n              : Math.abs(endX - x1) < epsilon && endY - y0 > epsilon ? [x1, Math.abs(startX - x1) < epsilon ? startY : y0]\r\n              : Math.abs(endY - y0) < epsilon && endX - x0 > epsilon ? [Math.abs(startY - y0) < epsilon ? startX : x0, y0]\r\n              : null)) - 1);\r\n          ++nHalfedges;\r\n        }\r\n      }\r\n\r\n      if (nHalfedges) cover = false;\r\n    }\r\n  }\r\n\r\n  // If there weren’t any edges, have the closest site cover the extent.\r\n  // It doesn’t matter which corner of the extent we measure!\r\n  if (cover) {\r\n    var dx, dy, d2, dc = Infinity;\r\n\r\n    for (iCell = 0, cover = null; iCell < nCells; ++iCell) {\r\n      if (cell = cells[iCell]) {\r\n        site = cell.site;\r\n        dx = site[0] - x0;\r\n        dy = site[1] - y0;\r\n        d2 = dx * dx + dy * dy;\r\n        if (d2 < dc) dc = d2, cover = cell;\r\n      }\r\n    }\r\n\r\n    if (cover) {\r\n      var v00 = [x0, y0], v01 = [x0, y1], v11 = [x1, y1], v10 = [x1, y0];\r\n      cover.halfedges.push(\r\n        edges.push(createBorderEdge(site = cover.site, v00, v01)) - 1,\r\n        edges.push(createBorderEdge(site, v01, v11)) - 1,\r\n        edges.push(createBorderEdge(site, v11, v10)) - 1,\r\n        edges.push(createBorderEdge(site, v10, v00)) - 1\r\n      );\r\n    }\r\n  }\r\n\r\n  // Lastly delete any cells with no edges; these were entirely clipped.\r\n  for (iCell = 0; iCell < nCells; ++iCell) {\r\n    if (cell = cells[iCell]) {\r\n      if (!cell.halfedges.length) {\r\n        delete cells[iCell];\r\n      }\r\n    }\r\n  }\r\n}\r\n",null]}