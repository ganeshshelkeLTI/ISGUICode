{"remainingRequest":"D:\\ISG-InformX\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--8-1!D:\\ISG-InformX\\node_modules\\@okta\\okta-auth-js\\lib\\oauthUtil.js","dependencies":[{"path":"D:\\ISG-InformX\\node_modules\\@okta\\okta-auth-js\\lib\\oauthUtil.js","mtime":1562860445817},{"path":"D:\\ISG-InformX\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1562860456543},{"path":"D:\\ISG-InformX\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1562860430677}],"contextDependencies":[],"result":["/*!\r\n * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.\r\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\r\n *\r\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n *\r\n * See the License for the specific language governing permissions and limitations under the License.\r\n *\r\n */\r\n\r\n/* eslint-disable complexity, max-statements */\r\nvar http = require('./http');\r\nvar util = require('./util');\r\nvar storageUtil = require('./browser/browserStorage');\r\nvar AuthSdkError = require('./errors/AuthSdkError');\r\n\r\nvar httpCache = storageUtil.getHttpCache();\r\n\r\nfunction isToken(obj) {\r\n  if (obj &&\r\n      (obj.accessToken || obj.idToken) &&\r\n      Array.isArray(obj.scopes)) {\r\n    return true;\r\n  }\r\n  return false;\r\n}\r\n\r\nfunction addListener(eventTarget, name, fn) {\r\n  if (eventTarget.addEventListener) {\r\n    eventTarget.addEventListener(name, fn);\r\n  } else {\r\n    eventTarget.attachEvent('on' + name, fn);\r\n  }\r\n}\r\n\r\nfunction removeListener(eventTarget, name, fn) {\r\n  if (eventTarget.removeEventListener) {\r\n    eventTarget.removeEventListener(name, fn);\r\n  } else {\r\n    eventTarget.detachEvent('on' + name, fn);\r\n  }\r\n}\r\n\r\nfunction loadFrame(src) {\r\n  var iframe = document.createElement('iframe');\r\n  iframe.style.display = 'none';\r\n  iframe.src = src;\r\n\r\n  return document.body.appendChild(iframe);\r\n}\r\n\r\nfunction loadPopup(src, options) {\r\n  var title = options.popupTitle || 'External Identity Provider User Authentication';\r\n  var appearance = 'toolbar=no, scrollbars=yes, resizable=yes, ' +\r\n    'top=100, left=500, width=600, height=600';\r\n\r\n  if (util.isIE11OrLess()) {\r\n    // IE<=11 doesn't fully support postMessage at time of writting.\r\n    // the following simple solution happened to solve the issue\r\n    // without adding another proxy layer which makes flow more complecated.\r\n    var winEl = window.open('/', title, appearance);\r\n    winEl.location.href = src;\r\n    return winEl;\r\n  } else {\r\n    return window.open(src, title, appearance);\r\n  }\r\n}\r\n\r\nfunction getWellKnown(sdk, issuer) {\r\n  return http.get(sdk, (issuer || sdk.options.url) + '/.well-known/openid-configuration', {\r\n    cacheResponse: true\r\n  });\r\n}\r\n\r\nfunction getKey(sdk, issuer, kid) {\r\n  return getWellKnown(sdk, issuer)\r\n  .then(function(wellKnown) {\r\n    var jwksUri = wellKnown['jwks_uri'];\r\n\r\n    // Check our kid against the cached version (if it exists and isn't expired)\r\n    var cacheContents = httpCache.getStorage();\r\n    var cachedResponse = cacheContents[jwksUri];\r\n    if (cachedResponse && Date.now()/1000 < cachedResponse.expiresAt) {\r\n      var cachedKey = util.find(cachedResponse.response.keys, {\r\n        kid: kid\r\n      });\r\n\r\n      if (cachedKey) {\r\n        return cachedKey;\r\n      }\r\n    }\r\n\r\n    // Remove cache for the key\r\n    httpCache.clearStorage(jwksUri);\r\n\r\n    // Pull the latest keys if the key wasn't in the cache\r\n    return http.get(sdk, jwksUri, {\r\n      cacheResponse: true\r\n    })\r\n    .then(function(res) {\r\n      var key = util.find(res.keys, {\r\n        kid: kid\r\n      });\r\n\r\n      if (key) {\r\n        return key;\r\n      }\r\n\r\n      throw new AuthSdkError('The key id, ' + kid + ', was not found in the server\\'s keys');\r\n    });\r\n  });\r\n}\r\n\r\nfunction validateClaims(sdk, claims, validationParams) {\r\n  var aud = validationParams.clientId;\r\n  var iss = validationParams.issuer;\r\n  var nonce = validationParams.nonce;\r\n\r\n  if (!claims || !iss || !aud) {\r\n    throw new AuthSdkError('The jwt, iss, and aud arguments are all required');\r\n  }\r\n\r\n  if (nonce && claims.nonce !== nonce) {\r\n    throw new AuthSdkError('OAuth flow response nonce doesn\\'t match request nonce');\r\n  }\r\n\r\n  var now = Math.floor(new Date().getTime()/1000);\r\n\r\n  if (claims.iss !== iss) {\r\n    throw new AuthSdkError('The issuer [' + claims.iss + '] ' +\r\n      'does not match [' + iss + ']');\r\n  }\r\n\r\n  if (claims.aud !== aud) {\r\n    throw new AuthSdkError('The audience [' + claims.aud + '] ' +\r\n      'does not match [' + aud + ']');\r\n  }\r\n\r\n  if (claims.iat > claims.exp) {\r\n    throw new AuthSdkError('The JWT expired before it was issued');\r\n  }\r\n\r\n  if ((now - sdk.options.maxClockSkew) > claims.exp) {\r\n    throw new AuthSdkError('The JWT expired and is no longer valid');\r\n  }\r\n\r\n  if (claims.iat > (now + sdk.options.maxClockSkew)) {\r\n    throw new AuthSdkError('The JWT was issued in the future');\r\n  }\r\n}\r\n\r\nfunction getOAuthUrls(sdk, oauthParams, options) {\r\n  options = options || {};\r\n\r\n  // Get user-supplied arguments\r\n  var authorizeUrl = util.removeTrailingSlash(options.authorizeUrl) || sdk.options.authorizeUrl;\r\n  var issuer = util.removeTrailingSlash(options.issuer) || sdk.options.issuer;\r\n  var userinfoUrl = util.removeTrailingSlash(options.userinfoUrl) || sdk.options.userinfoUrl;\r\n\r\n  // If an issuer exists but it's not a url, assume it's an authServerId\r\n  if (issuer && !(/^https?:/.test(issuer))) {\r\n    // Make it a url\r\n    issuer = sdk.options.url + '/oauth2/' + issuer;\r\n  }\r\n\r\n  // If an authorizeUrl is supplied without an issuer, and an id_token is requested\r\n  if (!issuer && authorizeUrl &&\r\n      oauthParams.responseType.indexOf('id_token') !== -1) {\r\n    // The issuer is ambiguous, so we won't be able to validate the id_token jwt\r\n    throw new AuthSdkError('Cannot request idToken with an authorizeUrl without an issuer');\r\n  }\r\n\r\n  // If a token is requested without an issuer\r\n  if (!issuer && oauthParams.responseType.indexOf('token') !== -1) {\r\n    // If an authorizeUrl is supplied without a userinfoUrl\r\n    if (authorizeUrl && !userinfoUrl) {\r\n      // The userinfoUrl is ambiguous, so we won't be able to call getUserInfo\r\n      throw new AuthSdkError('Cannot request accessToken with an authorizeUrl without an issuer or userinfoUrl');\r\n    }\r\n\r\n    // If a userinfoUrl is supplied without a authorizeUrl\r\n    if (userinfoUrl && !authorizeUrl) {\r\n      // The authorizeUrl is ambiguous, so we won't be able to call the authorize endpoint\r\n      throw new AuthSdkError('Cannot request token with an userinfoUrl without an issuer or authorizeUrl');\r\n    }\r\n  }\r\n\r\n  var sharedResourceServerRegex = new RegExp('^https?://.*?/oauth2/.+');\r\n\r\n  // Default the issuer to our baseUrl\r\n  issuer = issuer || sdk.options.url;\r\n\r\n  // A shared resource server issuer looks like:\r\n  // https://example.okta.com/oauth2/aus8aus76q8iphupD0h7\r\n  if (sharedResourceServerRegex.test(issuer)) {\r\n    // A shared resource server authorizeUrl looks like:\r\n    // https://example.okta.com/oauth2/aus8aus76q8iphupD0h7/v1/authorize\r\n    authorizeUrl = authorizeUrl || issuer + '/v1/authorize';\r\n    // Shared resource server userinfoUrls look like:\r\n    // https://example.okta.com/oauth2/aus8aus76q8iphupD0h7/v1/userinfo\r\n    userinfoUrl = userinfoUrl || issuer + '/v1/userinfo';\r\n\r\n  // Normally looks like:\r\n  // https://example.okta.com\r\n  } else {\r\n    // Normal authorizeUrls look like:\r\n    // https://example.okta.com/oauth2/v1/authorize\r\n    authorizeUrl = authorizeUrl || issuer + '/oauth2/v1/authorize';\r\n    // Normal userinfoUrls look like:\r\n    // https://example.okta.com/oauth2/v1/userinfo\r\n    userinfoUrl = userinfoUrl || issuer + '/oauth2/v1/userinfo';\r\n  }\r\n\r\n  return {\r\n    issuer: issuer,\r\n    authorizeUrl: authorizeUrl,\r\n    userinfoUrl: userinfoUrl\r\n  };\r\n}\r\n\r\nfunction hashToObject(hash) {\r\n  // Predefine regexs for parsing hash\r\n  var plus2space = /\\+/g;\r\n  var paramSplit = /([^&=]+)=?([^&]*)/g;\r\n\r\n  // Remove the leading hash\r\n  var fragment = hash.substring(1);\r\n\r\n  var obj = {};\r\n\r\n  // Loop until we have no more params\r\n  var param;\r\n  while (true) { // eslint-disable-line no-constant-condition\r\n    param = paramSplit.exec(fragment);\r\n    if (!param) { break; }\r\n\r\n    var key = param[1];\r\n    var value = param[2];\r\n\r\n    // id_token should remain base64url encoded\r\n    if (key === 'id_token' || key === 'access_token' || key === 'code') {\r\n      obj[key] = value;\r\n    } else {\r\n      obj[key] = decodeURIComponent(value.replace(plus2space, ' '));\r\n    }\r\n  }\r\n  return obj;\r\n}\r\n\r\nmodule.exports = {\r\n  getWellKnown: getWellKnown,\r\n  getKey: getKey,\r\n  validateClaims: validateClaims,\r\n  getOAuthUrls: getOAuthUrls,\r\n  loadFrame: loadFrame,\r\n  loadPopup: loadPopup,\r\n  hashToObject: hashToObject,\r\n  isToken: isToken,\r\n  addListener: addListener,\r\n  removeListener: removeListener\r\n};\r\n",null]}