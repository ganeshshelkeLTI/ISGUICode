{"remainingRequest":"D:\\InformXUI\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--8-1!D:\\InformXUI\\node_modules\\@okta\\okta-auth-js\\lib\\TokenManager.js","dependencies":[{"path":"D:\\InformXUI\\node_modules\\@okta\\okta-auth-js\\lib\\TokenManager.js","mtime":1561962764625},{"path":"D:\\InformXUI\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1561962767981},{"path":"D:\\InformXUI\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1561962756102}],"contextDependencies":[],"result":["/*!\r\n * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.\r\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\r\n *\r\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n *\r\n * See the License for the specific language governing permissions and limitations under the License.\r\n *\r\n */\r\n\r\n/* eslint complexity:[0,8] max-statements:[0,21] */\r\nvar util = require('./util');\r\nvar AuthSdkError = require('./errors/AuthSdkError');\r\nvar storageUtil = require('./browser/browserStorage');\r\nvar Q = require('q');\r\nvar Emitter = require('tiny-emitter');\r\nvar config = require('./config');\r\nvar storageBuilder = require('./storageBuilder');\r\n\r\nfunction emitExpired(tokenMgmtRef, key, token) {\r\n  tokenMgmtRef.emitter.emit('expired', key, token);\r\n}\r\n\r\nfunction emitError(tokenMgmtRef, error) {\r\n  tokenMgmtRef.emitter.emit('error', error);\r\n}\r\n\r\nfunction clearExpireEventTimeout(tokenMgmtRef, key) {\r\n  clearTimeout(tokenMgmtRef.expireTimeouts[key]);\r\n  delete tokenMgmtRef.expireTimeouts[key];\r\n\r\n  // Remove the renew promise (if it exists)\r\n  delete tokenMgmtRef.renewPromise[key];\r\n}\r\n\r\nfunction clearExpireEventTimeoutAll(tokenMgmtRef) {\r\n  var expireTimeouts = tokenMgmtRef.expireTimeouts;\r\n  for (var key in expireTimeouts) {\r\n    if (!expireTimeouts.hasOwnProperty(key)) {\r\n      continue;\r\n    }\r\n    clearExpireEventTimeout(tokenMgmtRef, key);\r\n  }\r\n}\r\n\r\nfunction setExpireEventTimeout(sdk, tokenMgmtRef, key, token) {\r\n  var clockSkew = sdk.options.maxClockSkew * 1000;\r\n  var expireEventWait = (token.expiresAt * 1000) - (Date.now() - clockSkew);\r\n\r\n  // Clear any existing timeout\r\n  clearExpireEventTimeout(tokenMgmtRef, key);\r\n\r\n  var expireEventTimeout = setTimeout(function() {\r\n    emitExpired(tokenMgmtRef, key, token);\r\n  }, expireEventWait);\r\n\r\n  // Add a new timeout\r\n  tokenMgmtRef.expireTimeouts[key] = expireEventTimeout;\r\n}\r\n\r\nfunction setExpireEventTimeoutAll(sdk, tokenMgmtRef, storage) {\r\n  try {\r\n    var tokenStorage = storage.getStorage();\r\n  } catch(e) {\r\n    // Any errors thrown on instantiation will not be caught,\r\n    // because there are no listeners yet\r\n    emitError(tokenMgmtRef, e);\r\n    return;\r\n  }\r\n\r\n  for(var key in tokenStorage) {\r\n    if (!tokenStorage.hasOwnProperty(key)) {\r\n      continue;\r\n    }\r\n    var token = tokenStorage[key];\r\n    setExpireEventTimeout(sdk, tokenMgmtRef, key, token);\r\n  }\r\n}\r\n\r\nfunction add(sdk, tokenMgmtRef, storage, key, token) {\r\n  var tokenStorage = storage.getStorage();\r\n  if (!util.isObject(token) ||\r\n      !token.scopes ||\r\n      (!token.expiresAt && token.expiresAt !== 0) ||\r\n      (!token.idToken && !token.accessToken)) {\r\n    throw new AuthSdkError('Token must be an Object with scopes, expiresAt, and an idToken or accessToken properties');\r\n  }\r\n  tokenStorage[key] = token;\r\n  storage.setStorage(tokenStorage);\r\n  setExpireEventTimeout(sdk, tokenMgmtRef, key, token);\r\n}\r\n\r\nfunction get(storage, key) {\r\n  var tokenStorage = storage.getStorage();\r\n  return tokenStorage[key];\r\n}\r\n\r\nfunction getAsync(sdk, tokenMgmtRef, storage, key) {\r\n  return Q.Promise(function(resolve) {\r\n    var token = get(storage, key);\r\n    var clockSkew = sdk.options.maxClockSkew * 1000;\r\n    if (!token || (token.expiresAt * 1000 - clockSkew) > Date.now()) {\r\n      return resolve(token);\r\n    }\r\n\r\n    var tokenPromise = tokenMgmtRef.autoRenew\r\n      ? renew(sdk, tokenMgmtRef, storage, key)\r\n      : remove(tokenMgmtRef, storage, key);\r\n\r\n    return resolve(tokenPromise);\r\n  });\r\n}\r\n\r\nfunction remove(tokenMgmtRef, storage, key) {\r\n  // Clear any listener for this token\r\n  clearExpireEventTimeout(tokenMgmtRef, key);\r\n\r\n  // Remove it from storage\r\n  var tokenStorage = storage.getStorage();\r\n  delete tokenStorage[key];\r\n  storage.setStorage(tokenStorage);\r\n}\r\n\r\nfunction renew(sdk, tokenMgmtRef, storage, key) {\r\n  try {\r\n    var token = get(storage, key);\r\n    if (!token) {\r\n      throw new AuthSdkError('The tokenManager has no token for the key: ' + key);\r\n    }\r\n  } catch (e) {\r\n    return Q.reject(e);\r\n  }\r\n\r\n  // Remove existing autoRenew timeout for this key\r\n  clearExpireEventTimeout(tokenMgmtRef, key);\r\n\r\n  // Store the renew promise state, to avoid renewing again\r\n  if (!tokenMgmtRef.renewPromise[key]) {\r\n    tokenMgmtRef.renewPromise[key] = sdk.token.renew(token)\r\n    .then(function(freshToken) {\r\n      if (!get(storage, key)) {\r\n        // It is possible to enter a state where the tokens have been cleared\r\n        // after a renewal request was triggered. To ensure we do not store a\r\n        // renewed token, we verify the promise key doesn't exist and return.\r\n        return;\r\n      }\r\n      add(sdk, tokenMgmtRef, storage, key, freshToken);\r\n      tokenMgmtRef.emitter.emit('renewed', key, freshToken, token);\r\n      // Remove existing promise key\r\n      delete tokenMgmtRef.renewPromise[key];\r\n      return freshToken;\r\n    })\r\n    .fail(function(err) {\r\n      if (err.name === 'OAuthError') {\r\n        remove(tokenMgmtRef, storage, key);\r\n        emitError(tokenMgmtRef, err);\r\n      }\r\n\r\n      throw err;\r\n    });\r\n  }\r\n  return tokenMgmtRef.renewPromise[key];\r\n}\r\n\r\nfunction clear(tokenMgmtRef, storage) {\r\n  clearExpireEventTimeoutAll(tokenMgmtRef);\r\n  storage.clearStorage();\r\n}\r\n\r\nfunction TokenManager(sdk, options) {\r\n  options = options || {};\r\n  options.storage = options.storage || 'localStorage';\r\n  if (!options.autoRenew && options.autoRenew !== false) {\r\n    options.autoRenew = true;\r\n  }\r\n\r\n  if (options.storage === 'localStorage' && !storageUtil.browserHasLocalStorage()) {\r\n    util.warn('This browser doesn\\'t support localStorage. Switching to sessionStorage.');\r\n    options.storage = 'sessionStorage';\r\n  }\r\n\r\n  if (options.storage === 'sessionStorage' && !storageUtil.browserHasSessionStorage()) {\r\n    util.warn('This browser doesn\\'t support sessionStorage. Switching to cookie-based storage.');\r\n    options.storage = 'cookie';\r\n  }\r\n\r\n  var storage;\r\n  switch(options.storage) {\r\n    case 'localStorage':\r\n      storage = storageBuilder(localStorage, config.TOKEN_STORAGE_NAME);\r\n      break;\r\n    case 'sessionStorage':\r\n      storage = storageBuilder(sessionStorage, config.TOKEN_STORAGE_NAME);\r\n      break;\r\n    case 'cookie':\r\n      storage = storageBuilder(storageUtil.getCookieStorage(), config.TOKEN_STORAGE_NAME);\r\n      break;\r\n    default:\r\n      throw new AuthSdkError('Unrecognized storage option');\r\n  }\r\n\r\n  var tokenMgmtRef = {\r\n    emitter: new Emitter(),\r\n    autoRenew: options.autoRenew,\r\n    expireTimeouts: {},\r\n    renewPromise: {}\r\n  };\r\n\r\n  this.add = util.bind(add, this, sdk, tokenMgmtRef, storage);\r\n  this.get = util.bind(getAsync, this, sdk, tokenMgmtRef, storage);\r\n  this.remove = util.bind(remove, this, tokenMgmtRef, storage);\r\n  this.clear = util.bind(clear, this, tokenMgmtRef, storage);\r\n  this.renew = util.bind(renew, this, sdk, tokenMgmtRef, storage);\r\n  this.on = util.bind(tokenMgmtRef.emitter.on, tokenMgmtRef.emitter);\r\n  this.off = util.bind(tokenMgmtRef.emitter.off, tokenMgmtRef.emitter);\r\n\r\n  setExpireEventTimeoutAll(sdk, tokenMgmtRef, storage);\r\n}\r\n\r\nmodule.exports = TokenManager;\r\n",null]}