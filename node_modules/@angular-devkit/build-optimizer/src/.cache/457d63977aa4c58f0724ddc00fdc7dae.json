{"remainingRequest":"D:\\ISG-InformX\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--8-1!D:\\ISG-InformX\\node_modules\\d3-zoom\\src\\zoom.js","dependencies":[{"path":"D:\\ISG-InformX\\node_modules\\d3-zoom\\src\\zoom.js","mtime":1562860465526},{"path":"D:\\ISG-InformX\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1562860456543},{"path":"D:\\ISG-InformX\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1562860430677}],"contextDependencies":[],"result":["import {dispatch} from \"d3-dispatch\";\r\nimport {dragDisable, dragEnable} from \"d3-drag\";\r\nimport {interpolateZoom} from \"d3-interpolate\";\r\nimport {event, customEvent, select, mouse, touch} from \"d3-selection\";\r\nimport {interrupt} from \"d3-transition\";\r\nimport constant from \"./constant\";\r\nimport ZoomEvent from \"./event\";\r\nimport {Transform, identity} from \"./transform\";\r\nimport noevent, {nopropagation} from \"./noevent\";\r\n\r\n// Ignore right-click, since that should open the context menu.\r\nfunction defaultFilter() {\r\n  return !event.button;\r\n}\r\n\r\nfunction defaultExtent() {\r\n  var e = this, w, h;\r\n  if (e instanceof SVGElement) {\r\n    e = e.ownerSVGElement || e;\r\n    w = e.width.baseVal.value;\r\n    h = e.height.baseVal.value;\r\n  } else {\r\n    w = e.clientWidth;\r\n    h = e.clientHeight;\r\n  }\r\n  return [[0, 0], [w, h]];\r\n}\r\n\r\nfunction defaultTransform() {\r\n  return this.__zoom || identity;\r\n}\r\n\r\nfunction defaultWheelDelta() {\r\n  return -event.deltaY * (event.deltaMode ? 120 : 1) / 500;\r\n}\r\n\r\nfunction defaultTouchable() {\r\n  return \"ontouchstart\" in this;\r\n}\r\n\r\nfunction defaultConstrain(transform, extent, translateExtent) {\r\n  var dx0 = transform.invertX(extent[0][0]) - translateExtent[0][0],\r\n      dx1 = transform.invertX(extent[1][0]) - translateExtent[1][0],\r\n      dy0 = transform.invertY(extent[0][1]) - translateExtent[0][1],\r\n      dy1 = transform.invertY(extent[1][1]) - translateExtent[1][1];\r\n  return transform.translate(\r\n    dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),\r\n    dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)\r\n  );\r\n}\r\n\r\nexport default function() {\r\n  var filter = defaultFilter,\r\n      extent = defaultExtent,\r\n      constrain = defaultConstrain,\r\n      wheelDelta = defaultWheelDelta,\r\n      touchable = defaultTouchable,\r\n      scaleExtent = [0, Infinity],\r\n      translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]],\r\n      duration = 250,\r\n      interpolate = interpolateZoom,\r\n      gestures = [],\r\n      listeners = dispatch(\"start\", \"zoom\", \"end\"),\r\n      touchstarting,\r\n      touchending,\r\n      touchDelay = 500,\r\n      wheelDelay = 150,\r\n      clickDistance2 = 0;\r\n\r\n  function zoom(selection) {\r\n    selection\r\n        .property(\"__zoom\", defaultTransform)\r\n        .on(\"wheel.zoom\", wheeled)\r\n        .on(\"mousedown.zoom\", mousedowned)\r\n        .on(\"dblclick.zoom\", dblclicked)\r\n      .filter(touchable)\r\n        .on(\"touchstart.zoom\", touchstarted)\r\n        .on(\"touchmove.zoom\", touchmoved)\r\n        .on(\"touchend.zoom touchcancel.zoom\", touchended)\r\n        .style(\"touch-action\", \"none\")\r\n        .style(\"-webkit-tap-highlight-color\", \"rgba(0,0,0,0)\");\r\n  }\r\n\r\n  zoom.transform = function(collection, transform) {\r\n    var selection = collection.selection ? collection.selection() : collection;\r\n    selection.property(\"__zoom\", defaultTransform);\r\n    if (collection !== selection) {\r\n      schedule(collection, transform);\r\n    } else {\r\n      selection.interrupt().each(function() {\r\n        gesture(this, arguments)\r\n            .start()\r\n            .zoom(null, typeof transform === \"function\" ? transform.apply(this, arguments) : transform)\r\n            .end();\r\n      });\r\n    }\r\n  };\r\n\r\n  zoom.scaleBy = function(selection, k) {\r\n    zoom.scaleTo(selection, function() {\r\n      var k0 = this.__zoom.k,\r\n          k1 = typeof k === \"function\" ? k.apply(this, arguments) : k;\r\n      return k0 * k1;\r\n    });\r\n  };\r\n\r\n  zoom.scaleTo = function(selection, k) {\r\n    zoom.transform(selection, function() {\r\n      var e = extent.apply(this, arguments),\r\n          t0 = this.__zoom,\r\n          p0 = centroid(e),\r\n          p1 = t0.invert(p0),\r\n          k1 = typeof k === \"function\" ? k.apply(this, arguments) : k;\r\n      return constrain(translate(scale(t0, k1), p0, p1), e, translateExtent);\r\n    });\r\n  };\r\n\r\n  zoom.translateBy = function(selection, x, y) {\r\n    zoom.transform(selection, function() {\r\n      return constrain(this.__zoom.translate(\r\n        typeof x === \"function\" ? x.apply(this, arguments) : x,\r\n        typeof y === \"function\" ? y.apply(this, arguments) : y\r\n      ), extent.apply(this, arguments), translateExtent);\r\n    });\r\n  };\r\n\r\n  zoom.translateTo = function(selection, x, y) {\r\n    zoom.transform(selection, function() {\r\n      var e = extent.apply(this, arguments),\r\n          t = this.__zoom,\r\n          p = centroid(e);\r\n      return constrain(identity.translate(p[0], p[1]).scale(t.k).translate(\r\n        typeof x === \"function\" ? -x.apply(this, arguments) : -x,\r\n        typeof y === \"function\" ? -y.apply(this, arguments) : -y\r\n      ), e, translateExtent);\r\n    });\r\n  };\r\n\r\n  function scale(transform, k) {\r\n    k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k));\r\n    return k === transform.k ? transform : new Transform(k, transform.x, transform.y);\r\n  }\r\n\r\n  function translate(transform, p0, p1) {\r\n    var x = p0[0] - p1[0] * transform.k, y = p0[1] - p1[1] * transform.k;\r\n    return x === transform.x && y === transform.y ? transform : new Transform(transform.k, x, y);\r\n  }\r\n\r\n  function centroid(extent) {\r\n    return [(+extent[0][0] + +extent[1][0]) / 2, (+extent[0][1] + +extent[1][1]) / 2];\r\n  }\r\n\r\n  function schedule(transition, transform, center) {\r\n    transition\r\n        .on(\"start.zoom\", function() { gesture(this, arguments).start(); })\r\n        .on(\"interrupt.zoom end.zoom\", function() { gesture(this, arguments).end(); })\r\n        .tween(\"zoom\", function() {\r\n          var that = this,\r\n              args = arguments,\r\n              g = gesture(that, args),\r\n              e = extent.apply(that, args),\r\n              p = center || centroid(e),\r\n              w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]),\r\n              a = that.__zoom,\r\n              b = typeof transform === \"function\" ? transform.apply(that, args) : transform,\r\n              i = interpolate(a.invert(p).concat(w / a.k), b.invert(p).concat(w / b.k));\r\n          return function(t) {\r\n            if (t === 1) t = b; // Avoid rounding error on end.\r\n            else { var l = i(t), k = w / l[2]; t = new Transform(k, p[0] - l[0] * k, p[1] - l[1] * k); }\r\n            g.zoom(null, t);\r\n          };\r\n        });\r\n  }\r\n\r\n  function gesture(that, args) {\r\n    for (var i = 0, n = gestures.length, g; i < n; ++i) {\r\n      if ((g = gestures[i]).that === that) {\r\n        return g;\r\n      }\r\n    }\r\n    return new Gesture(that, args);\r\n  }\r\n\r\n  function Gesture(that, args) {\r\n    this.that = that;\r\n    this.args = args;\r\n    this.index = -1;\r\n    this.active = 0;\r\n    this.extent = extent.apply(that, args);\r\n  }\r\n\r\n  Gesture.prototype = {\r\n    start: function() {\r\n      if (++this.active === 1) {\r\n        this.index = gestures.push(this) - 1;\r\n        this.emit(\"start\");\r\n      }\r\n      return this;\r\n    },\r\n    zoom: function(key, transform) {\r\n      if (this.mouse && key !== \"mouse\") this.mouse[1] = transform.invert(this.mouse[0]);\r\n      if (this.touch0 && key !== \"touch\") this.touch0[1] = transform.invert(this.touch0[0]);\r\n      if (this.touch1 && key !== \"touch\") this.touch1[1] = transform.invert(this.touch1[0]);\r\n      this.that.__zoom = transform;\r\n      this.emit(\"zoom\");\r\n      return this;\r\n    },\r\n    end: function() {\r\n      if (--this.active === 0) {\r\n        gestures.splice(this.index, 1);\r\n        this.index = -1;\r\n        this.emit(\"end\");\r\n      }\r\n      return this;\r\n    },\r\n    emit: function(type) {\r\n      customEvent(new ZoomEvent(zoom, type, this.that.__zoom), listeners.apply, listeners, [type, this.that, this.args]);\r\n    }\r\n  };\r\n\r\n  function wheeled() {\r\n    if (!filter.apply(this, arguments)) return;\r\n    var g = gesture(this, arguments),\r\n        t = this.__zoom,\r\n        k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t.k * Math.pow(2, wheelDelta.apply(this, arguments)))),\r\n        p = mouse(this);\r\n\r\n    // If the mouse is in the same location as before, reuse it.\r\n    // If there were recent wheel events, reset the wheel idle timeout.\r\n    if (g.wheel) {\r\n      if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {\r\n        g.mouse[1] = t.invert(g.mouse[0] = p);\r\n      }\r\n      clearTimeout(g.wheel);\r\n    }\r\n\r\n    // If this wheel event wonâ€™t trigger a transform change, ignore it.\r\n    else if (t.k === k) return;\r\n\r\n    // Otherwise, capture the mouse point and location at the start.\r\n    else {\r\n      g.mouse = [p, t.invert(p)];\r\n      interrupt(this);\r\n      g.start();\r\n    }\r\n\r\n    noevent();\r\n    g.wheel = setTimeout(wheelidled, wheelDelay);\r\n    g.zoom(\"mouse\", constrain(translate(scale(t, k), g.mouse[0], g.mouse[1]), g.extent, translateExtent));\r\n\r\n    function wheelidled() {\r\n      g.wheel = null;\r\n      g.end();\r\n    }\r\n  }\r\n\r\n  function mousedowned() {\r\n    if (touchending || !filter.apply(this, arguments)) return;\r\n    var g = gesture(this, arguments),\r\n        v = select(event.view).on(\"mousemove.zoom\", mousemoved, true).on(\"mouseup.zoom\", mouseupped, true),\r\n        p = mouse(this),\r\n        x0 = event.clientX,\r\n        y0 = event.clientY;\r\n\r\n    dragDisable(event.view);\r\n    nopropagation();\r\n    g.mouse = [p, this.__zoom.invert(p)];\r\n    interrupt(this);\r\n    g.start();\r\n\r\n    function mousemoved() {\r\n      noevent();\r\n      if (!g.moved) {\r\n        var dx = event.clientX - x0, dy = event.clientY - y0;\r\n        g.moved = dx * dx + dy * dy > clickDistance2;\r\n      }\r\n      g.zoom(\"mouse\", constrain(translate(g.that.__zoom, g.mouse[0] = mouse(g.that), g.mouse[1]), g.extent, translateExtent));\r\n    }\r\n\r\n    function mouseupped() {\r\n      v.on(\"mousemove.zoom mouseup.zoom\", null);\r\n      dragEnable(event.view, g.moved);\r\n      noevent();\r\n      g.end();\r\n    }\r\n  }\r\n\r\n  function dblclicked() {\r\n    if (!filter.apply(this, arguments)) return;\r\n    var t0 = this.__zoom,\r\n        p0 = mouse(this),\r\n        p1 = t0.invert(p0),\r\n        k1 = t0.k * (event.shiftKey ? 0.5 : 2),\r\n        t1 = constrain(translate(scale(t0, k1), p0, p1), extent.apply(this, arguments), translateExtent);\r\n\r\n    noevent();\r\n    if (duration > 0) select(this).transition().duration(duration).call(schedule, t1, p0);\r\n    else select(this).call(zoom.transform, t1);\r\n  }\r\n\r\n  function touchstarted() {\r\n    if (!filter.apply(this, arguments)) return;\r\n    var g = gesture(this, arguments),\r\n        touches = event.changedTouches,\r\n        started,\r\n        n = touches.length, i, t, p;\r\n\r\n    nopropagation();\r\n    for (i = 0; i < n; ++i) {\r\n      t = touches[i], p = touch(this, touches, t.identifier);\r\n      p = [p, this.__zoom.invert(p), t.identifier];\r\n      if (!g.touch0) g.touch0 = p, started = true;\r\n      else if (!g.touch1) g.touch1 = p;\r\n    }\r\n\r\n    // If this is a dbltap, reroute to the (optional) dblclick.zoom handler.\r\n    if (touchstarting) {\r\n      touchstarting = clearTimeout(touchstarting);\r\n      if (!g.touch1) {\r\n        g.end();\r\n        p = select(this).on(\"dblclick.zoom\");\r\n        if (p) p.apply(this, arguments);\r\n        return;\r\n      }\r\n    }\r\n\r\n    if (started) {\r\n      touchstarting = setTimeout(function() { touchstarting = null; }, touchDelay);\r\n      interrupt(this);\r\n      g.start();\r\n    }\r\n  }\r\n\r\n  function touchmoved() {\r\n    var g = gesture(this, arguments),\r\n        touches = event.changedTouches,\r\n        n = touches.length, i, t, p, l;\r\n\r\n    noevent();\r\n    if (touchstarting) touchstarting = clearTimeout(touchstarting);\r\n    for (i = 0; i < n; ++i) {\r\n      t = touches[i], p = touch(this, touches, t.identifier);\r\n      if (g.touch0 && g.touch0[2] === t.identifier) g.touch0[0] = p;\r\n      else if (g.touch1 && g.touch1[2] === t.identifier) g.touch1[0] = p;\r\n    }\r\n    t = g.that.__zoom;\r\n    if (g.touch1) {\r\n      var p0 = g.touch0[0], l0 = g.touch0[1],\r\n          p1 = g.touch1[0], l1 = g.touch1[1],\r\n          dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp,\r\n          dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;\r\n      t = scale(t, Math.sqrt(dp / dl));\r\n      p = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];\r\n      l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];\r\n    }\r\n    else if (g.touch0) p = g.touch0[0], l = g.touch0[1];\r\n    else return;\r\n    g.zoom(\"touch\", constrain(translate(t, p, l), g.extent, translateExtent));\r\n  }\r\n\r\n  function touchended() {\r\n    var g = gesture(this, arguments),\r\n        touches = event.changedTouches,\r\n        n = touches.length, i, t;\r\n\r\n    nopropagation();\r\n    if (touchending) clearTimeout(touchending);\r\n    touchending = setTimeout(function() { touchending = null; }, touchDelay);\r\n    for (i = 0; i < n; ++i) {\r\n      t = touches[i];\r\n      if (g.touch0 && g.touch0[2] === t.identifier) delete g.touch0;\r\n      else if (g.touch1 && g.touch1[2] === t.identifier) delete g.touch1;\r\n    }\r\n    if (g.touch1 && !g.touch0) g.touch0 = g.touch1, delete g.touch1;\r\n    if (g.touch0) g.touch0[1] = this.__zoom.invert(g.touch0[0]);\r\n    else g.end();\r\n  }\r\n\r\n  zoom.wheelDelta = function(_) {\r\n    return arguments.length ? (wheelDelta = typeof _ === \"function\" ? _ : constant(+_), zoom) : wheelDelta;\r\n  };\r\n\r\n  zoom.filter = function(_) {\r\n    return arguments.length ? (filter = typeof _ === \"function\" ? _ : constant(!!_), zoom) : filter;\r\n  };\r\n\r\n  zoom.touchable = function(_) {\r\n    return arguments.length ? (touchable = typeof _ === \"function\" ? _ : constant(!!_), zoom) : touchable;\r\n  };\r\n\r\n  zoom.extent = function(_) {\r\n    return arguments.length ? (extent = typeof _ === \"function\" ? _ : constant([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), zoom) : extent;\r\n  };\r\n\r\n  zoom.scaleExtent = function(_) {\r\n    return arguments.length ? (scaleExtent[0] = +_[0], scaleExtent[1] = +_[1], zoom) : [scaleExtent[0], scaleExtent[1]];\r\n  };\r\n\r\n  zoom.translateExtent = function(_) {\r\n    return arguments.length ? (translateExtent[0][0] = +_[0][0], translateExtent[1][0] = +_[1][0], translateExtent[0][1] = +_[0][1], translateExtent[1][1] = +_[1][1], zoom) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];\r\n  };\r\n\r\n  zoom.constrain = function(_) {\r\n    return arguments.length ? (constrain = _, zoom) : constrain;\r\n  };\r\n\r\n  zoom.duration = function(_) {\r\n    return arguments.length ? (duration = +_, zoom) : duration;\r\n  };\r\n\r\n  zoom.interpolate = function(_) {\r\n    return arguments.length ? (interpolate = _, zoom) : interpolate;\r\n  };\r\n\r\n  zoom.on = function() {\r\n    var value = listeners.on.apply(listeners, arguments);\r\n    return value === listeners ? zoom : value;\r\n  };\r\n\r\n  zoom.clickDistance = function(_) {\r\n    return arguments.length ? (clickDistance2 = (_ = +_) * _, zoom) : Math.sqrt(clickDistance2);\r\n  };\r\n\r\n  return zoom;\r\n}\r\n",null]}