{"remainingRequest":"D:\\InformXUI\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--8-1!D:\\InformXUI\\node_modules\\@okta\\okta-auth-js\\lib\\token.js","dependencies":[{"path":"D:\\InformXUI\\node_modules\\@okta\\okta-auth-js\\lib\\token.js","mtime":1561962764641},{"path":"D:\\InformXUI\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1561962767981},{"path":"D:\\InformXUI\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1561962756102}],"contextDependencies":[],"result":["/*!\r\n * Copyright (c) 2015-present, Okta, Inc. and/or its affiliates. All rights reserved.\r\n * The Okta software accompanied by this notice is provided pursuant to the Apache License, Version 2.0 (the \"License.\")\r\n *\r\n * You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\r\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n *\r\n * See the License for the specific language governing permissions and limitations under the License.\r\n *\r\n */\r\n\r\n/* eslint-disable complexity, max-statements */\r\nvar http          = require('./http');\r\nvar util          = require('./util');\r\nvar oauthUtil     = require('./oauthUtil');\r\nvar Q             = require('q');\r\nvar sdkCrypto     = require('./crypto');\r\nvar AuthSdkError  = require('./errors/AuthSdkError');\r\nvar OAuthError    = require('./errors/OAuthError');\r\nvar config        = require('./config');\r\nvar cookies       = require('./browser/browserStorage').storage;\r\n\r\nfunction decodeToken(token) {\r\n  var jwt = token.split('.');\r\n  var decodedToken;\r\n\r\n  try {\r\n    decodedToken = {\r\n      header: JSON.parse(util.base64UrlToString(jwt[0])),\r\n      payload: JSON.parse(util.base64UrlToString(jwt[1])),\r\n      signature: jwt[2]\r\n    };\r\n  } catch(e) {\r\n    throw new AuthSdkError('Malformed token');\r\n  }\r\n\r\n  return decodedToken;\r\n}\r\n\r\nfunction verifyToken(sdk, token, validationParams) {\r\n  return new Q()\r\n  .then(function() {\r\n    if (!token || !token.idToken) {\r\n      throw new AuthSdkError('Only idTokens may be verified');\r\n    }\r\n\r\n    var jwt = decodeToken(token.idToken);\r\n\r\n    var validationOptions = {\r\n      clientId: sdk.options.clientId,\r\n      issuer: sdk.options.issuer || sdk.options.url,\r\n      ignoreSignature: sdk.options.ignoreSignature\r\n    };\r\n\r\n    util.extend(validationOptions, validationParams);\r\n\r\n    // Standard claim validation\r\n    oauthUtil.validateClaims(sdk, jwt.payload, validationOptions);\r\n\r\n    // If the browser doesn't support native crypto or we choose not\r\n    // to verify the signature, bail early\r\n    if (validationOptions.ignoreSignature == true || !sdk.features.isTokenVerifySupported()) {\r\n      return token;\r\n    }\r\n\r\n    return oauthUtil.getKey(sdk, token.issuer, jwt.header.kid)\r\n    .then(function(key) {\r\n      return sdkCrypto.verifyToken(token.idToken, key);\r\n    })\r\n    .then(function(valid) {\r\n      if (!valid) {\r\n        throw new AuthSdkError('The token signature is not valid');\r\n      }\r\n      return token;\r\n    });\r\n  });\r\n}\r\n\r\nfunction addPostMessageListener(sdk, timeout, state) {\r\n  var deferred = Q.defer();\r\n\r\n  function responseHandler(e) {\r\n    if (!e.data ||\r\n        e.origin !== sdk.options.url ||\r\n        (e.data && util.isString(state) && e.data.state !== state)) {\r\n      return;\r\n    }\r\n    deferred.resolve(e.data);\r\n  }\r\n\r\n  oauthUtil.addListener(window, 'message', responseHandler);\r\n\r\n  return deferred.promise.timeout(timeout || 120000, new AuthSdkError('OAuth flow timed out'))\r\n    .fin(function() {\r\n      oauthUtil.removeListener(window, 'message', responseHandler);\r\n    });\r\n}\r\n\r\nfunction addFragmentListener(sdk, windowEl, timeout) {\r\n  var deferred = Q.defer();\r\n\r\n  function hashChangeHandler() {\r\n    /*\r\n      We are only able to access window.location.hash on a window\r\n      that has the same domain. A try/catch is necessary because\r\n      there's no other way to determine that the popup is in\r\n      another domain. When we try to access a window on another\r\n      domain, an error is thrown.\r\n    */\r\n    try {\r\n      if (windowEl &&\r\n          windowEl.location &&\r\n          windowEl.location.hash) {\r\n        deferred.resolve(oauthUtil.hashToObject(windowEl.location.hash));\r\n      } else if (windowEl && !windowEl.closed) {\r\n        setTimeout(hashChangeHandler, 500);\r\n      }\r\n    } catch (err) {\r\n      setTimeout(hashChangeHandler, 500);\r\n    }\r\n  }\r\n\r\n  hashChangeHandler();\r\n\r\n  return deferred.promise.timeout(timeout || 120000, new AuthSdkError('OAuth flow timed out'));\r\n}\r\n\r\nfunction handleOAuthResponse(sdk, oauthParams, res, urls) {\r\n  urls = urls || {};\r\n\r\n  var tokenTypes = oauthParams.responseType;\r\n  var scopes = util.clone(oauthParams.scopes);\r\n  var clientId = oauthParams.clientId || sdk.options.clientId;\r\n\r\n  return new Q()\r\n  .then(function() {\r\n    if (res['error'] || res['error_description']) {\r\n      throw new OAuthError(res['error'], res['error_description']);\r\n    }\r\n\r\n    if (res.state !== oauthParams.state) {\r\n      throw new AuthSdkError('OAuth flow response state doesn\\'t match request state');\r\n    }\r\n\r\n    var tokenDict = {};\r\n\r\n    if (res['access_token']) {\r\n      tokenDict['token'] = {\r\n        accessToken: res['access_token'],\r\n        expiresAt: Number(res['expires_in']) + Math.floor(Date.now()/1000),\r\n        tokenType: res['token_type'],\r\n        scopes: scopes,\r\n        authorizeUrl: urls.authorizeUrl,\r\n        userinfoUrl: urls.userinfoUrl\r\n      };\r\n    }\r\n\r\n    if (res['code']) {\r\n      tokenDict['code'] = {\r\n        authorizationCode: res['code']\r\n      };\r\n    }\r\n\r\n    if (res['id_token']) {\r\n      var jwt = sdk.token.decode(res['id_token']);\r\n\r\n      var idToken = {\r\n        idToken: res['id_token'],\r\n        claims: jwt.payload,\r\n        expiresAt: jwt.payload.exp,\r\n        scopes: scopes,\r\n        authorizeUrl: urls.authorizeUrl,\r\n        issuer: urls.issuer,\r\n        clientId: clientId\r\n      };\r\n\r\n      var validationParams = {\r\n        clientId: clientId,\r\n        issuer: urls.issuer,\r\n        nonce: oauthParams.nonce,\r\n        ignoreSignature: oauthParams.ignoreSignature\r\n      };\r\n\r\n      return verifyToken(sdk, idToken, validationParams)\r\n      .then(function() {\r\n        tokenDict['id_token'] = idToken;\r\n        return tokenDict;\r\n      });\r\n    }\r\n\r\n    return tokenDict;\r\n  })\r\n  .then(function(tokenDict) {\r\n    if (!Array.isArray(tokenTypes)) {\r\n      return tokenDict[tokenTypes];\r\n    }\r\n\r\n    if (!tokenDict['token'] && !tokenDict['id_token']) {\r\n      throw new AuthSdkError('Unable to parse OAuth flow response');\r\n    }\r\n\r\n    // Create token array in the order of the responseType array\r\n    return tokenTypes.map(function(item) {\r\n      return tokenDict[item];\r\n    });\r\n  });\r\n}\r\n\r\nfunction getDefaultOAuthParams(sdk, oauthOptions) {\r\n  oauthOptions = util.clone(oauthOptions) || {};\r\n\r\n  var defaults = {\r\n    clientId: sdk.options.clientId,\r\n    redirectUri: sdk.options.redirectUri || window.location.href,\r\n    responseType: 'id_token',\r\n    responseMode: 'okta_post_message',\r\n    state: util.genRandomString(64),\r\n    nonce: util.genRandomString(64),\r\n    scopes: ['openid', 'email'],\r\n    ignoreSignature: sdk.options.ignoreSignature\r\n  };\r\n  util.extend(defaults, oauthOptions);\r\n  return defaults;\r\n}\r\n\r\nfunction convertOAuthParamsToQueryParams(oauthParams) {\r\n  // Quick validation\r\n  if (!oauthParams.clientId) {\r\n    throw new AuthSdkError('A clientId must be specified in the OktaAuth constructor to get a token');\r\n  }\r\n\r\n  if (util.isString(oauthParams.responseType) && oauthParams.responseType.indexOf(' ') !== -1) {\r\n    throw new AuthSdkError('Multiple OAuth responseTypes must be defined as an array');\r\n  }\r\n\r\n  // Convert our params to their actual OAuth equivalents\r\n  var oauthQueryParams = util.removeNils({\r\n    'client_id': oauthParams.clientId,\r\n    'redirect_uri': oauthParams.redirectUri,\r\n    'response_type': oauthParams.responseType,\r\n    'response_mode': oauthParams.responseMode,\r\n    'state': oauthParams.state,\r\n    'nonce': oauthParams.nonce,\r\n    'prompt': oauthParams.prompt,\r\n    'display': oauthParams.display,\r\n    'sessionToken': oauthParams.sessionToken,\r\n    'idp': oauthParams.idp,\r\n    'max_age': oauthParams.maxAge\r\n  });\r\n\r\n  if (Array.isArray(oauthQueryParams['response_type'])) {\r\n    oauthQueryParams['response_type'] = oauthQueryParams['response_type'].join(' ');\r\n  }\r\n\r\n  if (oauthParams.responseType.indexOf('id_token') !== -1 &&\r\n      oauthParams.scopes.indexOf('openid') === -1) {\r\n    throw new AuthSdkError('openid scope must be specified in the scopes argument when requesting an id_token');\r\n  } else {\r\n    oauthQueryParams.scope = oauthParams.scopes.join(' ');\r\n  }\r\n\r\n  return oauthQueryParams;\r\n}\r\n\r\nfunction buildAuthorizeParams(oauthParams) {\r\n  var oauthQueryParams = convertOAuthParamsToQueryParams(oauthParams);\r\n  return util.toQueryParams(oauthQueryParams);\r\n}\r\n\r\n/*\r\n * Retrieve an idToken from an Okta or a third party idp\r\n *\r\n * Two main flows:\r\n *\r\n *  1) Exchange a sessionToken for a token\r\n *\r\n *    Required:\r\n *      clientId: passed via the OktaAuth constructor or into getToken\r\n *      sessionToken: 'yourtoken'\r\n *\r\n *    Optional:\r\n *      redirectUri: defaults to window.location.href\r\n *      scopes: defaults to ['openid', 'email']\r\n *\r\n *    Forced:\r\n *      prompt: 'none'\r\n *      responseMode: 'okta_post_message'\r\n *      display: undefined\r\n *\r\n *  2) Get a token from an idp\r\n *\r\n *    Required:\r\n *      clientId: passed via the OktaAuth constructor or into getToken\r\n *\r\n *    Optional:\r\n *      redirectUri: defaults to window.location.href\r\n *      scopes: defaults to ['openid', 'email']\r\n *      idp: defaults to Okta as an idp\r\n *      prompt: no default. Pass 'none' to throw an error if user is not signed in\r\n *\r\n *    Forced:\r\n *      display: 'popup'\r\n *\r\n *  Only common optional params shown. Any OAuth parameters not explicitly forced are available to override\r\n *\r\n * @param {Object} oauthOptions\r\n * @param {String} [oauthOptions.clientId] ID of this client\r\n * @param {String} [oauthOptions.redirectUri] URI that the iframe or popup will go to once authenticated\r\n * @param {String[]} [oauthOptions.scopes] OAuth 2.0 scopes to request (openid must be specified)\r\n * @param {String} [oauthOptions.idp] ID of an external IdP to use for user authentication\r\n * @param {String} [oauthOptions.sessionToken] Bootstrap Session Token returned by the Okta Authentication API\r\n * @param {String} [oauthOptions.prompt] Determines whether the Okta login will be displayed on failure.\r\n *                                       Use 'none' to prevent this behavior\r\n *\r\n * @param {Object} options\r\n * @param {Integer} [options.timeout] Time in ms before the flow is automatically terminated. Defaults to 120000\r\n * @param {String} [options.popupTitle] Title dispayed in the popup.\r\n *                                      Defaults to 'External Identity Provider User Authentication'\r\n */\r\nfunction getToken(sdk, oauthOptions, options) {\r\n  oauthOptions = oauthOptions || {};\r\n  options = options || {};\r\n\r\n  // Default OAuth query params\r\n  var oauthParams = getDefaultOAuthParams(sdk, oauthOptions);\r\n\r\n  // Start overriding any options that don't make sense\r\n  var sessionTokenOverrides = {\r\n    prompt: 'none',\r\n    responseMode: 'okta_post_message',\r\n    display: null\r\n  };\r\n\r\n  var idpOverrides = {\r\n    display: 'popup'\r\n  };\r\n\r\n  if (oauthOptions.sessionToken) {\r\n    util.extend(oauthParams, sessionTokenOverrides);\r\n  } else if (oauthOptions.idp) {\r\n    util.extend(oauthParams, idpOverrides);\r\n  }\r\n\r\n  // Use the query params to build the authorize url\r\n  var requestUrl,\r\n      urls;\r\n  try {\r\n    // Get authorizeUrl and issuer\r\n    urls = oauthUtil.getOAuthUrls(sdk, oauthParams, options);\r\n    requestUrl = urls.authorizeUrl + buildAuthorizeParams(oauthParams);\r\n  } catch (e) {\r\n    return Q.reject(e);\r\n  }\r\n\r\n  // Determine the flow type\r\n  var flowType;\r\n  if (oauthParams.sessionToken || oauthParams.display === null) {\r\n    flowType = 'IFRAME';\r\n  } else if (oauthParams.display === 'popup') {\r\n    flowType = 'POPUP';\r\n  } else {\r\n    flowType = 'IMPLICIT';\r\n  }\r\n\r\n  function getOrigin(url) {\r\n    /* eslint-disable-next-line no-useless-escape */\r\n    var originRegex = /^(https?\\:\\/\\/)?([^:\\/?#]*(?:\\:[0-9]+)?)/;\r\n    return originRegex.exec(url)[0];\r\n  }\r\n\r\n  // Execute the flow type\r\n  switch (flowType) {\r\n    case 'IFRAME':\r\n      var iframePromise = addPostMessageListener(sdk, options.timeout, oauthParams.state);\r\n      var iframeEl = oauthUtil.loadFrame(requestUrl);\r\n      return iframePromise\r\n        .then(function(res) {\r\n          return handleOAuthResponse(sdk, oauthParams, res, urls);\r\n        })\r\n        .fin(function() {\r\n          if (document.body.contains(iframeEl)) {\r\n            iframeEl.parentElement.removeChild(iframeEl);\r\n          }\r\n        });\r\n\r\n    case 'POPUP': // eslint-disable-line no-case-declarations\r\n      var popupPromise;\r\n\r\n      // Add listener on postMessage before window creation, so\r\n      // postMessage isn't triggered before we're listening\r\n      if (oauthParams.responseMode === 'okta_post_message') {\r\n        if (!sdk.features.isPopupPostMessageSupported()) {\r\n          return Q.reject(new AuthSdkError('This browser doesn\\'t have full postMessage support'));\r\n        }\r\n        popupPromise = addPostMessageListener(sdk, options.timeout, oauthParams.state);\r\n      }\r\n\r\n      // Create the window\r\n      var windowOptions = {\r\n        popupTitle: options.popupTitle\r\n      };\r\n      var windowEl = oauthUtil.loadPopup(requestUrl, windowOptions);\r\n\r\n      // Poll until we get a valid hash fragment\r\n      if (oauthParams.responseMode === 'fragment') {\r\n        var windowOrigin = getOrigin(sdk.idToken.authorize._getLocationHref());\r\n        var redirectUriOrigin = getOrigin(oauthParams.redirectUri);\r\n        if (windowOrigin !== redirectUriOrigin) {\r\n          return Q.reject(new AuthSdkError('Using fragment, the redirectUri origin (' + redirectUriOrigin +\r\n            ') must match the origin of this page (' + windowOrigin + ')'));\r\n        }\r\n        popupPromise = addFragmentListener(sdk, windowEl, options.timeout);\r\n      }\r\n\r\n      // Both postMessage and fragment require a poll to see if the popup closed\r\n      var popupDeferred = Q.defer();\r\n      /* eslint-disable-next-line no-case-declarations, no-inner-declarations */\r\n      function hasClosed(win) {\r\n        if (win.closed) {\r\n          popupDeferred.reject(new AuthSdkError('Unable to parse OAuth flow response'));\r\n        }\r\n      }\r\n      var closePoller = setInterval(function() {\r\n        hasClosed(windowEl);\r\n      }, 500);\r\n\r\n      // Proxy the promise results into the deferred\r\n      popupPromise\r\n      .then(function(res) {\r\n        popupDeferred.resolve(res);\r\n      })\r\n      .fail(function(err) {\r\n        popupDeferred.reject(err);\r\n      });\r\n\r\n      return popupDeferred.promise\r\n        .then(function(res) {\r\n          return handleOAuthResponse(sdk, oauthParams, res, urls);\r\n        })\r\n        .fin(function() {\r\n          if (!windowEl.closed) {\r\n            clearInterval(closePoller);\r\n            windowEl.close();\r\n          }\r\n        });\r\n\r\n    default:\r\n      return Q.reject(new AuthSdkError('The full page redirect flow is not supported'));\r\n  }\r\n}\r\n\r\nfunction getWithoutPrompt(sdk, oauthOptions, options) {\r\n  var oauthParams = util.clone(oauthOptions) || {};\r\n  util.extend(oauthParams, {\r\n    prompt: 'none',\r\n    responseMode: 'okta_post_message',\r\n    display: null\r\n  });\r\n  return getToken(sdk, oauthParams, options);\r\n}\r\n\r\nfunction getWithPopup(sdk, oauthOptions, options) {\r\n  var oauthParams = util.clone(oauthOptions) || {};\r\n  util.extend(oauthParams, {\r\n    display: 'popup'\r\n  });\r\n  return getToken(sdk, oauthParams, options);\r\n}\r\n\r\nfunction getWithRedirect(sdk, oauthOptions, options) {\r\n  oauthOptions = util.clone(oauthOptions) || {};\r\n  var oauthParams = getDefaultOAuthParams(sdk, oauthOptions);\r\n  // If the user didn't specify a responseMode\r\n  if (!oauthOptions.responseMode) {\r\n    // And it's only an auth code request (responseType could be an array)\r\n    var respType = oauthParams.responseType;\r\n    if (respType.indexOf('code') !== -1 &&\r\n        (util.isString(respType) || (Array.isArray(respType) && respType.length === 1))) {\r\n        // Default the responseMode to query\r\n        util.extend(oauthParams, {\r\n          responseMode: 'query'\r\n        });\r\n    // Otherwise, default to fragment\r\n    } else {\r\n      util.extend(oauthParams, {\r\n        responseMode: 'fragment'\r\n      });\r\n    }\r\n  }\r\n\r\n  var urls = oauthUtil.getOAuthUrls(sdk, oauthParams, options);\r\n  var requestUrl = urls.authorizeUrl + buildAuthorizeParams(oauthParams);\r\n\r\n  // Set session cookie to store the oauthParams\r\n  cookies.set(config.REDIRECT_OAUTH_PARAMS_COOKIE_NAME, JSON.stringify({\r\n    responseType: oauthParams.responseType,\r\n    state: oauthParams.state,\r\n    nonce: oauthParams.nonce,\r\n    scopes: oauthParams.scopes,\r\n    clientId: oauthParams.clientId,\r\n    urls: urls,\r\n    ignoreSignature: oauthParams.ignoreSignature\r\n  }));\r\n\r\n  // Set nonce cookie for servers to validate nonce in id_token\r\n  cookies.set(config.REDIRECT_NONCE_COOKIE_NAME, oauthParams.nonce);\r\n\r\n  // Set state cookie for servers to validate state\r\n  cookies.set(config.REDIRECT_STATE_COOKIE_NAME, oauthParams.state);\r\n\r\n  sdk.token.getWithRedirect._setLocation(requestUrl);\r\n}\r\n\r\nfunction renewToken(sdk, token) {\r\n  if (!oauthUtil.isToken(token)) {\r\n    return Q.reject(new AuthSdkError('Renew must be passed a token with ' +\r\n      'an array of scopes and an accessToken or idToken'));\r\n  }\r\n\r\n  var responseType;\r\n  if (token.accessToken) {\r\n    responseType = 'token';\r\n  } else {\r\n    responseType = 'id_token';\r\n  }\r\n  return sdk.token.getWithoutPrompt({\r\n    responseType: responseType,\r\n    scopes: token.scopes\r\n  }, {\r\n    authorizeUrl: token.authorizeUrl,\r\n    userinfoUrl: token.userinfoUrl,\r\n    issuer: token.issuer\r\n  });\r\n}\r\n\r\nfunction removeHash(sdk) {\r\n  var nativeHistory = sdk.token.parseFromUrl._getHistory();\r\n  var nativeDoc = sdk.token.parseFromUrl._getDocument();\r\n  var nativeLoc = sdk.token.parseFromUrl._getLocation();\r\n  if (nativeHistory && nativeHistory.replaceState) {\r\n    nativeHistory.replaceState(null, nativeDoc.title, nativeLoc.pathname + nativeLoc.search);\r\n  } else {\r\n    nativeLoc.hash = '';\r\n  }\r\n}\r\n\r\nfunction parseFromUrl(sdk, url) {\r\n  var nativeLoc = sdk.token.parseFromUrl._getLocation();\r\n  var hash = nativeLoc.hash;\r\n  if (url) {\r\n    hash = url.substring(url.indexOf('#'));\r\n  }\r\n\r\n  if (!hash) {\r\n    return Q.reject(new AuthSdkError('Unable to parse a token from the url'));\r\n  }\r\n\r\n  var oauthParamsCookie = cookies.get(config.REDIRECT_OAUTH_PARAMS_COOKIE_NAME);\r\n  if (!oauthParamsCookie) {\r\n    return Q.reject(new AuthSdkError('Unable to retrieve OAuth redirect params cookie'));\r\n  }\r\n\r\n  try {\r\n    var oauthParams = JSON.parse(oauthParamsCookie);\r\n    var urls = oauthParams.urls;\r\n    delete oauthParams.urls;\r\n    cookies.delete(config.REDIRECT_OAUTH_PARAMS_COOKIE_NAME);\r\n  } catch(e) {\r\n    return Q.reject(new AuthSdkError('Unable to parse the ' +\r\n      config.REDIRECT_OAUTH_PARAMS_COOKIE_NAME + ' cookie: ' + e.message));\r\n  }\r\n\r\n  return Q.resolve(oauthUtil.hashToObject(hash))\r\n    .then(function(res) {\r\n      if (!url) {\r\n        // Remove the hash from the url\r\n        removeHash(sdk);\r\n      }\r\n      return handleOAuthResponse(sdk, oauthParams, res, urls);\r\n    });\r\n}\r\n\r\nfunction getUserInfo(sdk, accessTokenObject) {\r\n  if (!accessTokenObject ||\r\n      (!oauthUtil.isToken(accessTokenObject) && !accessTokenObject.accessToken && !accessTokenObject.userinfoUrl)) {\r\n    return Q.reject(new AuthSdkError('getUserInfo requires an access token object'));\r\n  }\r\n  return http.httpRequest(sdk, {\r\n    url: accessTokenObject.userinfoUrl,\r\n    method: 'GET',\r\n    accessToken: accessTokenObject.accessToken\r\n  })\r\n  .fail(function(err) {\r\n    if (err.xhr && (err.xhr.status === 401 || err.xhr.status === 403)) {\r\n      var authenticateHeader = err.xhr.getResponseHeader('WWW-Authenticate');\r\n      if (authenticateHeader) {\r\n        var errorMatches = authenticateHeader.match(/error=\"(.*?)\"/) || [];\r\n        var errorDescriptionMatches = authenticateHeader.match(/error_description=\"(.*?)\"/) || [];\r\n        var error = errorMatches[1];\r\n        var errorDescription = errorDescriptionMatches[1];\r\n        if (error && errorDescription) {\r\n          err = new OAuthError(error, errorDescription);\r\n        }\r\n      }\r\n    }\r\n    throw err;\r\n  });\r\n}\r\n\r\nmodule.exports = {\r\n  getToken: getToken,\r\n  getWithoutPrompt: getWithoutPrompt,\r\n  getWithPopup: getWithPopup,\r\n  getWithRedirect: getWithRedirect,\r\n  parseFromUrl: parseFromUrl,\r\n  decodeToken: decodeToken,\r\n  renewToken: renewToken,\r\n  getUserInfo: getUserInfo,\r\n  verifyToken: verifyToken\r\n};\r\n",null]}