{"remainingRequest":"F:\\deployment-notification-cr\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--8-1!F:\\deployment-notification-cr\\node_modules\\d3-polygon\\src\\hull.js","dependencies":[{"path":"F:\\deployment-notification-cr\\node_modules\\d3-polygon\\src\\hull.js","mtime":1584689774894},{"path":"F:\\deployment-notification-cr\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1584689768230},{"path":"F:\\deployment-notification-cr\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1584689753517}],"contextDependencies":[],"result":["import cross from \"./cross\";\r\n\r\nfunction lexicographicOrder(a, b) {\r\n  return a[0] - b[0] || a[1] - b[1];\r\n}\r\n\r\n// Computes the upper convex hull per the monotone chain algorithm.\r\n// Assumes points.length >= 3, is sorted by x, unique in y.\r\n// Returns an array of indices into points in left-to-right order.\r\nfunction computeUpperHullIndexes(points) {\r\n  var n = points.length,\r\n      indexes = [0, 1],\r\n      size = 2;\r\n\r\n  for (var i = 2; i < n; ++i) {\r\n    while (size > 1 && cross(points[indexes[size - 2]], points[indexes[size - 1]], points[i]) <= 0) --size;\r\n    indexes[size++] = i;\r\n  }\r\n\r\n  return indexes.slice(0, size); // remove popped points\r\n}\r\n\r\nexport default function(points) {\r\n  if ((n = points.length) < 3) return null;\r\n\r\n  var i,\r\n      n,\r\n      sortedPoints = new Array(n),\r\n      flippedPoints = new Array(n);\r\n\r\n  for (i = 0; i < n; ++i) sortedPoints[i] = [+points[i][0], +points[i][1], i];\r\n  sortedPoints.sort(lexicographicOrder);\r\n  for (i = 0; i < n; ++i) flippedPoints[i] = [sortedPoints[i][0], -sortedPoints[i][1]];\r\n\r\n  var upperIndexes = computeUpperHullIndexes(sortedPoints),\r\n      lowerIndexes = computeUpperHullIndexes(flippedPoints);\r\n\r\n  // Construct the hull polygon, removing possible duplicate endpoints.\r\n  var skipLeft = lowerIndexes[0] === upperIndexes[0],\r\n      skipRight = lowerIndexes[lowerIndexes.length - 1] === upperIndexes[upperIndexes.length - 1],\r\n      hull = [];\r\n\r\n  // Add upper hull in right-to-l order.\r\n  // Then add lower hull in left-to-right order.\r\n  for (i = upperIndexes.length - 1; i >= 0; --i) hull.push(points[sortedPoints[upperIndexes[i]][2]]);\r\n  for (i = +skipLeft; i < lowerIndexes.length - skipRight; ++i) hull.push(points[sortedPoints[lowerIndexes[i]][2]]);\r\n\r\n  return hull;\r\n}\r\n",null]}