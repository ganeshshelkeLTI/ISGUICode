{"remainingRequest":"F:\\deployment-notification-cr\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--8-1!F:\\deployment-notification-cr\\node_modules\\ng2-charts\\fesm5\\ng2-charts.js","dependencies":[{"path":"F:\\deployment-notification-cr\\node_modules\\ng2-charts\\fesm5\\ng2-charts.js","mtime":1584689802015},{"path":"F:\\deployment-notification-cr\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1584689768230},{"path":"F:\\deployment-notification-cr\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1584689753517}],"contextDependencies":[],"result":["/** PURE_IMPORTS_START tslib,chart.js,_angular_core,rxjs,lodash PURE_IMPORTS_END */\nimport { __spread, __assign } from 'tslib';\nimport { Chart as Chart$1 } from 'chart.js';\nimport { Injectable, NgModule, EventEmitter, Directive, ElementRef, Input, Output, defineInjectable } from '@angular/core';\nimport { BehaviorSubject } from 'rxjs';\nimport { cloneDeep } from 'lodash';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nvar defaultColors = [\n    [255, 99, 132],\n    [54, 162, 235],\n    [255, 206, 86],\n    [231, 233, 237],\n    [75, 192, 192],\n    [151, 187, 205],\n    [220, 220, 220],\n    [247, 70, 74],\n    [70, 191, 189],\n    [253, 180, 92],\n    [148, 159, 177],\n    [77, 83, 96]\n];\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Generate colors by chart type\n * @param {?} chartType\n * @param {?} index\n * @param {?} count\n * @return {?}\n */\nfunction getColors(chartType, index, count) {\n    if (chartType === 'pie' || chartType === 'doughnut') {\n        return formatPieColors(generateColors(count));\n    }\n    if (chartType === 'polarArea') {\n        return formatPolarAreaColors(generateColors(count));\n    }\n    if (chartType === 'line' || chartType === 'radar') {\n        return formatLineColor(generateColor(index));\n    }\n    if (chartType === 'bar' || chartType === 'horizontalBar') {\n        return formatBarColor(generateColor(index));\n    }\n    if (chartType === 'bubble') {\n        return formatPieColors(generateColors(count));\n    }\n    if (chartType === 'scatter') {\n        return formatPieColors(generateColors(count));\n    }\n    throw new Error(\"getColors - Unsupported chart type \" + chartType);\n}\n/**\n * @param {?} colour\n * @param {?} alpha\n * @return {?}\n */\nfunction rgba(colour, alpha) {\n    return 'rgba(' + colour.concat(alpha).join(',') + ')';\n}\n/**\n * @param {?} min\n * @param {?} max\n * @return {?}\n */\nfunction getRandomInt(min, max) {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n}\n/**\n * @param {?} colors\n * @return {?}\n */\nfunction formatLineColor(colors) {\n    return {\n        backgroundColor: rgba(colors, 0.4),\n        borderColor: rgba(colors, 1),\n        pointBackgroundColor: rgba(colors, 1),\n        pointBorderColor: '#fff',\n        pointHoverBackgroundColor: '#fff',\n        pointHoverBorderColor: rgba(colors, 0.8)\n    };\n}\n/**\n * @param {?} colors\n * @return {?}\n */\nfunction formatBarColor(colors) {\n    return {\n        backgroundColor: rgba(colors, 0.6),\n        borderColor: rgba(colors, 1),\n        hoverBackgroundColor: rgba(colors, 0.8),\n        hoverBorderColor: rgba(colors, 1)\n    };\n}\n/**\n * @param {?} colors\n * @return {?}\n */\nfunction formatPieColors(colors) {\n    return {\n        backgroundColor: colors.map(( /**\n         * @param {?} color\n         * @return {?}\n         */function (color) { return rgba(color, 0.6); })),\n        borderColor: colors.map(( /**\n         * @return {?}\n         */function () { return '#fff'; })),\n        pointBackgroundColor: colors.map(( /**\n         * @param {?} color\n         * @return {?}\n         */function (color) { return rgba(color, 1); })),\n        pointBorderColor: colors.map(( /**\n         * @return {?}\n         */function () { return '#fff'; })),\n        pointHoverBackgroundColor: colors.map(( /**\n         * @param {?} color\n         * @return {?}\n         */function (color) { return rgba(color, 1); })),\n        pointHoverBorderColor: colors.map(( /**\n         * @param {?} color\n         * @return {?}\n         */function (color) { return rgba(color, 1); }))\n    };\n}\n/**\n * @param {?} colors\n * @return {?}\n */\nfunction formatPolarAreaColors(colors) {\n    return {\n        backgroundColor: colors.map(( /**\n         * @param {?} color\n         * @return {?}\n         */function (color) { return rgba(color, 0.6); })),\n        borderColor: colors.map(( /**\n         * @param {?} color\n         * @return {?}\n         */function (color) { return rgba(color, 1); })),\n        hoverBackgroundColor: colors.map(( /**\n         * @param {?} color\n         * @return {?}\n         */function (color) { return rgba(color, 0.8); })),\n        hoverBorderColor: colors.map(( /**\n         * @param {?} color\n         * @return {?}\n         */function (color) { return rgba(color, 1); }))\n    };\n}\n/**\n * @return {?}\n */\nfunction getRandomColor() {\n    return [getRandomInt(0, 255), getRandomInt(0, 255), getRandomInt(0, 255)];\n}\n/**\n * Generate colors for line|bar charts\n * @param {?} index\n * @return {?}\n */\nfunction generateColor(index) {\n    return defaultColors[index] || getRandomColor();\n}\n/**\n * Generate colors for pie|doughnut charts\n * @param {?} count\n * @return {?}\n */\nfunction generateColors(count) {\n    /** @type {?} */\n    var colorsArr = new Array(count);\n    for (var i = 0; i < count; i++) {\n        colorsArr[i] = defaultColors[i] || getRandomColor();\n    }\n    return colorsArr;\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar ThemeService = /** @class */ /*@__PURE__*/ (function () {\n    function ThemeService() {\n        this.pColorschemesOptions = {};\n        this.colorschemesOptions = new BehaviorSubject({});\n    }\n    /**\n     * @param {?} options\n     * @return {?}\n     */\n    ThemeService.prototype.setColorschemesOptions = /**\n     * @param {?} options\n     * @return {?}\n     */\n        function (options) {\n            this.pColorschemesOptions = options;\n            this.colorschemesOptions.next(options);\n        };\n    /**\n     * @return {?}\n     */\n    ThemeService.prototype.getColorschemesOptions = /**\n     * @return {?}\n     */\n        function () {\n            return this.pColorschemesOptions;\n        };\n    /** @nocollapse */ ThemeService.ngInjectableDef = defineInjectable({ factory: function ThemeService_Factory() { return new ThemeService(); }, token: ThemeService, providedIn: \"root\" });\n    return ThemeService;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @enum {number} */\nvar UpdateType = /*@__PURE__*/ (function () {\n    var UpdateType = {\n        Default: 0,\n        Update: 1,\n        Refresh: 2,\n    };\n    UpdateType[UpdateType.Default] = 'Default';\n    UpdateType[UpdateType.Update] = 'Update';\n    UpdateType[UpdateType.Refresh] = 'Refresh';\n    return UpdateType;\n}());\nvar BaseChartDirective = /** @class */ /*@__PURE__*/ (function () {\n    function BaseChartDirective(element, themeService) {\n        this.element = element;\n        this.themeService = themeService;\n        this.options = {};\n        this.chartClick = new EventEmitter();\n        this.chartHover = new EventEmitter();\n        this.old = {\n            dataExists: false,\n            dataLength: 0,\n            datasetsExists: false,\n            datasetsLength: 0,\n            datasetsDataObjects: [],\n            datasetsDataLengths: [],\n            colorsExists: false,\n            colors: [],\n            labelsExist: false,\n            labels: [],\n            legendExists: false,\n            legend: {},\n        };\n        this.subs = [];\n    }\n    /**\n     * Register a plugin.\n     */\n    /**\n     * Register a plugin.\n     * @param {?} plugin\n     * @return {?}\n     */\n    BaseChartDirective.registerPlugin = /**\n     * Register a plugin.\n     * @param {?} plugin\n     * @return {?}\n     */\n        function (plugin) {\n            Chart$1.plugins.register(plugin);\n        };\n    /**\n     * @param {?} plugin\n     * @return {?}\n     */\n    BaseChartDirective.unregisterPlugin = /**\n     * @param {?} plugin\n     * @return {?}\n     */\n        function (plugin) {\n            Chart$1.plugins.unregister(plugin);\n        };\n    /**\n     * @return {?}\n     */\n    BaseChartDirective.prototype.ngOnInit = /**\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            this.ctx = this.element.nativeElement.getContext('2d');\n            this.refresh();\n            this.subs.push(this.themeService.colorschemesOptions.subscribe(( /**\n             * @param {?} r\n             * @return {?}\n             */function (r) { return _this.themeChanged(r); })));\n        };\n    /**\n     * @private\n     * @param {?} options\n     * @return {?}\n     */\n    BaseChartDirective.prototype.themeChanged = /**\n     * @private\n     * @param {?} options\n     * @return {?}\n     */\n        function (options) {\n            this.refresh();\n        };\n    /**\n     * @return {?}\n     */\n    BaseChartDirective.prototype.ngDoCheck = /**\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            if (!this.chart) {\n                return;\n            }\n            /** @type {?} */\n            var updateRequired = UpdateType.Default;\n            /** @type {?} */\n            var wantUpdate = ( /**\n             * @param {?} x\n             * @return {?}\n             */function (x) {\n                updateRequired = x > updateRequired ? x : updateRequired;\n            });\n            if (!!this.data !== this.old.dataExists) {\n                this.propagateDataToDatasets(this.data);\n                this.old.dataExists = !!this.data;\n                wantUpdate(UpdateType.Update);\n            }\n            if (this.data && this.data.length !== this.old.dataLength) {\n                this.old.dataLength = this.data && this.data.length || 0;\n                wantUpdate(UpdateType.Update);\n            }\n            if (!!this.datasets !== this.old.datasetsExists) {\n                this.old.datasetsExists = !!this.datasets;\n                wantUpdate(UpdateType.Update);\n            }\n            if (this.datasets && this.datasets.length !== this.old.datasetsLength) {\n                this.old.datasetsLength = this.datasets && this.datasets.length || 0;\n                wantUpdate(UpdateType.Update);\n            }\n            if (this.datasets && this.datasets.filter(( /**\n             * @param {?} x\n             * @param {?} i\n             * @return {?}\n             */function (x, i) { return x.data !== _this.old.datasetsDataObjects[i]; })).length) {\n                this.old.datasetsDataObjects = this.datasets.map(( /**\n                 * @param {?} x\n                 * @return {?}\n                 */function (x) { return x.data; }));\n                wantUpdate(UpdateType.Update);\n            }\n            if (this.datasets && this.datasets.filter(( /**\n             * @param {?} x\n             * @param {?} i\n             * @return {?}\n             */function (x, i) { return x.data.length !== _this.old.datasetsDataLengths[i]; })).length) {\n                this.old.datasetsDataLengths = this.datasets.map(( /**\n                 * @param {?} x\n                 * @return {?}\n                 */function (x) { return x.data.length; }));\n                wantUpdate(UpdateType.Update);\n            }\n            if (!!this.colors !== this.old.colorsExists) {\n                this.old.colorsExists = !!this.colors;\n                this.updateColors();\n                wantUpdate(UpdateType.Update);\n            }\n            // This smells of inefficiency, might need to revisit this\n            if (this.colors && this.colors.filter(( /**\n             * @param {?} x\n             * @param {?} i\n             * @return {?}\n             */function (x, i) { return !_this.colorsEqual(x, _this.old.colors[i]); })).length) {\n                this.old.colors = this.colors.map(( /**\n                 * @param {?} x\n                 * @return {?}\n                 */function (x) { return _this.copyColor(x); }));\n                this.updateColors();\n                wantUpdate(UpdateType.Update);\n            }\n            if (!!this.labels !== this.old.labelsExist) {\n                this.old.labelsExist = !!this.labels;\n                wantUpdate(UpdateType.Update);\n            }\n            if (this.labels && this.labels.filter(( /**\n             * @param {?} x\n             * @param {?} i\n             * @return {?}\n             */function (x, i) { return !_this.labelsEqual(x, _this.old.labels[i]); })).length) {\n                this.old.labels = this.labels.map(( /**\n                 * @param {?} x\n                 * @return {?}\n                 */function (x) { return _this.copyLabel(x); }));\n                wantUpdate(UpdateType.Update);\n            }\n            if (!!this.options.legend !== this.old.legendExists) {\n                this.old.legendExists = !!this.options.legend;\n                wantUpdate(UpdateType.Refresh);\n            }\n            if (this.options.legend && this.options.legend.position !== this.old.legend.position) {\n                this.old.legend.position = this.options.legend.position;\n                wantUpdate(UpdateType.Refresh);\n            }\n            switch (( /** @type {?} */(updateRequired))) {\n                case UpdateType.Default:\n                    break;\n                case UpdateType.Update:\n                    this.update();\n                    break;\n                case UpdateType.Refresh:\n                    this.refresh();\n                    break;\n            }\n        };\n    /**\n     * @param {?} a\n     * @return {?}\n     */\n    BaseChartDirective.prototype.copyLabel = /**\n     * @param {?} a\n     * @return {?}\n     */\n        function (a) {\n            if (Array.isArray(a)) {\n                return __spread(a);\n            }\n            return a;\n        };\n    /**\n     * @param {?} a\n     * @param {?} b\n     * @return {?}\n     */\n    BaseChartDirective.prototype.labelsEqual = /**\n     * @param {?} a\n     * @param {?} b\n     * @return {?}\n     */\n        function (a, b) {\n            return Array.isArray(a) === Array.isArray(b)\n                && (Array.isArray(a) || a === b)\n                && (!Array.isArray(a) || a.length === b.length)\n                && (!Array.isArray(a) || a.filter(( /**\n                 * @param {?} x\n                 * @param {?} i\n                 * @return {?}\n                 */function (x, i) { return x !== b[i]; })).length === 0);\n        };\n    /**\n     * @param {?} a\n     * @return {?}\n     */\n    BaseChartDirective.prototype.copyColor = /**\n     * @param {?} a\n     * @return {?}\n     */\n        function (a) {\n            /** @type {?} */\n            var rc = {\n                backgroundColor: a.backgroundColor,\n                borderWidth: a.borderWidth,\n                borderColor: a.borderColor,\n                borderCapStyle: a.borderCapStyle,\n                borderDash: a.borderDash,\n                borderDashOffset: a.borderDashOffset,\n                borderJoinStyle: a.borderJoinStyle,\n                pointBorderColor: a.pointBorderColor,\n                pointBackgroundColor: a.pointBackgroundColor,\n                pointBorderWidth: a.pointBorderWidth,\n                pointRadius: a.pointRadius,\n                pointHoverRadius: a.pointHoverRadius,\n                pointHitRadius: a.pointHitRadius,\n                pointHoverBackgroundColor: a.pointHoverBackgroundColor,\n                pointHoverBorderColor: a.pointHoverBorderColor,\n                pointHoverBorderWidth: a.pointHoverBorderWidth,\n                pointStyle: a.pointStyle,\n                hoverBackgroundColor: a.hoverBackgroundColor,\n                hoverBorderColor: a.hoverBorderColor,\n                hoverBorderWidth: a.hoverBorderWidth,\n            };\n            return rc;\n        };\n    /**\n     * @param {?} a\n     * @param {?} b\n     * @return {?}\n     */\n    BaseChartDirective.prototype.colorsEqual = /**\n     * @param {?} a\n     * @param {?} b\n     * @return {?}\n     */\n        function (a, b) {\n            if (!a !== !b) {\n                return false;\n            }\n            return !a || a.backgroundColor === b.backgroundColor\n                && (a.borderWidth === b.borderWidth)\n                && (a.borderColor === b.borderColor)\n                && (a.borderCapStyle === b.borderCapStyle)\n                && (a.borderDash === b.borderDash)\n                && (a.borderDashOffset === b.borderDashOffset)\n                && (a.borderJoinStyle === b.borderJoinStyle)\n                && (a.pointBorderColor === b.pointBorderColor)\n                && (a.pointBackgroundColor === b.pointBackgroundColor)\n                && (a.pointBorderWidth === b.pointBorderWidth)\n                && (a.pointRadius === b.pointRadius)\n                && (a.pointHoverRadius === b.pointHoverRadius)\n                && (a.pointHitRadius === b.pointHitRadius)\n                && (a.pointHoverBackgroundColor === b.pointHoverBackgroundColor)\n                && (a.pointHoverBorderColor === b.pointHoverBorderColor)\n                && (a.pointHoverBorderWidth === b.pointHoverBorderWidth)\n                && (a.pointStyle === b.pointStyle)\n                && (a.hoverBackgroundColor === b.hoverBackgroundColor)\n                && (a.hoverBorderColor === b.hoverBorderColor)\n                && (a.hoverBorderWidth === b.hoverBorderWidth);\n        };\n    /**\n     * @return {?}\n     */\n    BaseChartDirective.prototype.updateColors = /**\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            this.datasets.forEach(( /**\n             * @param {?} elm\n             * @param {?} index\n             * @return {?}\n             */function (elm, index) {\n                if (_this.colors && _this.colors[index]) {\n                    Object.assign(elm, _this.colors[index]);\n                }\n                else {\n                    Object.assign(elm, getColors(_this.chartType, index, elm.data.length), __assign({}, elm));\n                }\n            }));\n        };\n    /**\n     * @param {?} changes\n     * @return {?}\n     */\n    BaseChartDirective.prototype.ngOnChanges = /**\n     * @param {?} changes\n     * @return {?}\n     */\n        function (changes) {\n            /** @type {?} */\n            var updateRequired = UpdateType.Default;\n            /** @type {?} */\n            var wantUpdate = ( /**\n             * @param {?} x\n             * @return {?}\n             */function (x) {\n                updateRequired = x > updateRequired ? x : updateRequired;\n            });\n            // Check if the changes are in the data or datasets or labels or legend\n            if (changes.hasOwnProperty('data') && changes.data.currentValue) {\n                this.propagateDataToDatasets(changes.data.currentValue);\n                wantUpdate(UpdateType.Update);\n            }\n            if (changes.hasOwnProperty('datasets') && changes.datasets.currentValue) {\n                this.propagateDatasetsToData(changes.datasets.currentValue);\n                wantUpdate(UpdateType.Update);\n            }\n            if (changes.hasOwnProperty('labels')) {\n                if (this.chart) {\n                    this.chart.data.labels = changes.labels.currentValue;\n                }\n                wantUpdate(UpdateType.Update);\n            }\n            if (changes.hasOwnProperty('legend')) {\n                if (this.chart) {\n                    this.chart.config.options.legend.display = changes.legend.currentValue;\n                    this.chart.generateLegend();\n                }\n                wantUpdate(UpdateType.Update);\n            }\n            if (changes.hasOwnProperty('options')) {\n                wantUpdate(UpdateType.Refresh);\n            }\n            switch (( /** @type {?} */(updateRequired))) {\n                case UpdateType.Update:\n                    this.update();\n                    break;\n                case UpdateType.Refresh:\n                case UpdateType.Default:\n                    this.refresh();\n                    break;\n            }\n        };\n    /**\n     * @return {?}\n     */\n    BaseChartDirective.prototype.ngOnDestroy = /**\n     * @return {?}\n     */\n        function () {\n            if (this.chart) {\n                this.chart.destroy();\n                this.chart = void 0;\n            }\n            this.subs.forEach(( /**\n             * @param {?} x\n             * @return {?}\n             */function (x) { return x.unsubscribe(); }));\n        };\n    /**\n     * @param {?=} duration\n     * @param {?=} lazy\n     * @return {?}\n     */\n    BaseChartDirective.prototype.update = /**\n     * @param {?=} duration\n     * @param {?=} lazy\n     * @return {?}\n     */\n        function (duration, lazy) {\n            if (this.chart) {\n                return this.chart.update(duration, lazy);\n            }\n        };\n    /**\n     * @param {?} index\n     * @param {?} hidden\n     * @return {?}\n     */\n    BaseChartDirective.prototype.hideDataset = /**\n     * @param {?} index\n     * @param {?} hidden\n     * @return {?}\n     */\n        function (index, hidden) {\n            this.chart.getDatasetMeta(index).hidden = hidden;\n            this.chart.update();\n        };\n    /**\n     * @param {?} index\n     * @return {?}\n     */\n    BaseChartDirective.prototype.isDatasetHidden = /**\n     * @param {?} index\n     * @return {?}\n     */\n        function (index) {\n            return this.chart.getDatasetMeta(index).hidden;\n        };\n    /**\n     * @return {?}\n     */\n    BaseChartDirective.prototype.toBase64Image = /**\n     * @return {?}\n     */\n        function () {\n            return this.chart.toBase64Image();\n        };\n    /**\n     * @return {?}\n     */\n    BaseChartDirective.prototype.getChartConfiguration = /**\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            /** @type {?} */\n            var datasets = this.getDatasets();\n            /** @type {?} */\n            var options = Object.assign({}, this.options);\n            if (this.legend === false) {\n                options.legend = { display: false };\n            }\n            // hook for onHover and onClick events\n            options.hover = options.hover || {};\n            if (!options.hover.onHover) {\n                options.hover.onHover = ( /**\n                 * @param {?} event\n                 * @param {?} active\n                 * @return {?}\n                 */function (event, active) {\n                    if (active && !active.length) {\n                        return;\n                    }\n                    _this.chartHover.emit({ event: event, active: active });\n                });\n            }\n            if (!options.onClick) {\n                options.onClick = ( /**\n                 * @param {?=} event\n                 * @param {?=} active\n                 * @return {?}\n                 */function (event, active) {\n                    _this.chartClick.emit({ event: event, active: active });\n                });\n            }\n            /** @type {?} */\n            var mergedOptions = this.smartMerge(options, this.themeService.getColorschemesOptions());\n            /** @type {?} */\n            var chartConfig = {\n                type: this.chartType,\n                data: {\n                    labels: this.labels || [],\n                    datasets: datasets\n                },\n                plugins: this.plugins,\n                options: mergedOptions,\n            };\n            return chartConfig;\n        };\n    /**\n     * @param {?} ctx\n     * @return {?}\n     */\n    BaseChartDirective.prototype.getChartBuilder = /**\n     * @param {?} ctx\n     * @return {?}\n     */\n        function (ctx /*, data:any[], options:any*/) {\n            /** @type {?} */\n            var chartConfig = this.getChartConfiguration();\n            return new Chart$1(ctx, chartConfig);\n        };\n    /**\n     * @param {?} options\n     * @param {?} overrides\n     * @param {?=} level\n     * @return {?}\n     */\n    BaseChartDirective.prototype.smartMerge = /**\n     * @param {?} options\n     * @param {?} overrides\n     * @param {?=} level\n     * @return {?}\n     */\n        function (options, overrides, level) {\n            var _this = this;\n            if (level === void 0) {\n                level = 0;\n            }\n            if (level === 0) {\n                options = cloneDeep(options);\n            }\n            /** @type {?} */\n            var keysToUpdate = Object.keys(overrides);\n            keysToUpdate.forEach(( /**\n             * @param {?} key\n             * @return {?}\n             */function (key) {\n                if (Array.isArray(overrides[key])) {\n                    /** @type {?} */\n                    var arrayElements = options[key];\n                    if (arrayElements) {\n                        arrayElements.forEach(( /**\n                         * @param {?} r\n                         * @return {?}\n                         */function (r) {\n                            _this.smartMerge(r, overrides[key][0], level + 1);\n                        }));\n                    }\n                }\n                else if (typeof (overrides[key]) === 'object') {\n                    if (!(key in options)) {\n                        options[key] = {};\n                    }\n                    _this.smartMerge(options[key], overrides[key], level + 1);\n                }\n                else {\n                    options[key] = overrides[key];\n                }\n            }));\n            if (level === 0) {\n                return options;\n            }\n        };\n    /**\n     * @private\n     * @param {?} label\n     * @return {?}\n     */\n    BaseChartDirective.prototype.isMultiLineLabel = /**\n     * @private\n     * @param {?} label\n     * @return {?}\n     */\n        function (label) {\n            return Array.isArray(label);\n        };\n    /**\n     * @private\n     * @param {?} label\n     * @return {?}\n     */\n    BaseChartDirective.prototype.joinLabel = /**\n     * @private\n     * @param {?} label\n     * @return {?}\n     */\n        function (label) {\n            if (!label) {\n                return null;\n            }\n            if (this.isMultiLineLabel(label)) {\n                return label.join(' ');\n            }\n            else {\n                return label;\n            }\n        };\n    /**\n     * @private\n     * @param {?} datasets\n     * @return {?}\n     */\n    BaseChartDirective.prototype.propagateDatasetsToData = /**\n     * @private\n     * @param {?} datasets\n     * @return {?}\n     */\n        function (datasets) {\n            this.data = this.datasets.map(( /**\n             * @param {?} r\n             * @return {?}\n             */function (r) { return r.data; }));\n            if (this.chart) {\n                this.chart.data.datasets = datasets;\n            }\n            this.updateColors();\n        };\n    /**\n     * @private\n     * @param {?} newDataValues\n     * @return {?}\n     */\n    BaseChartDirective.prototype.propagateDataToDatasets = /**\n     * @private\n     * @param {?} newDataValues\n     * @return {?}\n     */\n        function (newDataValues) {\n            var _this = this;\n            if (this.isMultiDataSet(newDataValues)) {\n                if (this.datasets && newDataValues.length === this.datasets.length) {\n                    this.datasets.forEach(( /**\n                     * @param {?} dataset\n                     * @param {?} i\n                     * @return {?}\n                     */function (dataset, i) {\n                        dataset.data = newDataValues[i];\n                    }));\n                }\n                else {\n                    this.datasets = newDataValues.map(( /**\n                     * @param {?} data\n                     * @param {?} index\n                     * @return {?}\n                     */function (data, index) {\n                        return { data: data, label: _this.joinLabel(_this.labels[index]) || \"Label \" + index };\n                    }));\n                    if (this.chart) {\n                        this.chart.data.datasets = this.datasets;\n                    }\n                }\n            }\n            else {\n                if (!this.datasets) {\n                    this.datasets = [{ data: newDataValues }];\n                    if (this.chart) {\n                        this.chart.data.datasets = this.datasets;\n                    }\n                }\n                else {\n                    this.datasets[0].data = newDataValues;\n                    this.datasets.splice(1); // Remove all elements but the first\n                }\n            }\n            this.updateColors();\n        };\n    /**\n     * @private\n     * @param {?} data\n     * @return {?}\n     */\n    BaseChartDirective.prototype.isMultiDataSet = /**\n     * @private\n     * @param {?} data\n     * @return {?}\n     */\n        function (data) {\n            return Array.isArray(data[0]);\n        };\n    /**\n     * @private\n     * @return {?}\n     */\n    BaseChartDirective.prototype.getDatasets = /**\n     * @private\n     * @return {?}\n     */\n        function () {\n            if (!this.datasets && !this.data) {\n                throw new Error(\"ng-charts configuration error, data or datasets field are required to render chart \" + this.chartType);\n            }\n            // If `datasets` is defined, use it over the `data` property.\n            if (this.datasets) {\n                this.propagateDatasetsToData(this.datasets);\n                return this.datasets;\n            }\n            if (this.data) {\n                this.propagateDataToDatasets(this.data);\n                return this.datasets;\n            }\n        };\n    /**\n     * @private\n     * @return {?}\n     */\n    BaseChartDirective.prototype.refresh = /**\n     * @private\n     * @return {?}\n     */\n        function () {\n            // if (this.options && this.options.responsive) {\n            //   setTimeout(() => this.refresh(), 50);\n            // }\n            // todo: remove this line, it is producing flickering\n            if (this.chart) {\n                this.chart.destroy();\n                this.chart = void 0;\n            }\n            if (this.ctx) {\n                this.chart = this.getChartBuilder(this.ctx /*, data, this.options*/);\n            }\n        };\n    return BaseChartDirective;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nvar ChartsModule = /** @class */ /*@__PURE__*/ (function () {\n    function ChartsModule() {\n    }\n    return ChartsModule;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n// tslint:disable:variable-name\n// tslint:disable:no-var-keyword\n// tslint:disable:prefer-const\n// tslint:disable:only-arrow-functions\n// tslint:disable:one-variable-per-declaration\n// tslint:disable:object-literal-shorthand\n// tslint:disable:space-before-function-paren\n/**\n * @return {?}\n */\nfunction monkeyPatchChartJsLegend() {\n    if (typeof Chart === 'undefined') {\n        console.log('Chart not defined (guessing this is a universal build, and I don\\'t know why this happens -- Aviad)');\n        return;\n    }\n    /** @type {?} */\n    var plugins = Chart.plugins.getAll();\n    /** @type {?} */\n    var legend = plugins.filter(( /**\n     * @param {?} p\n     * @return {?}\n     */function (p) { return p.id === 'legend'; }))[0];\n    legend._element.prototype.fit = fit;\n    legend._element.prototype.draw = draw;\n    /** @type {?} */\n    var helpers = Chart.helpers;\n    /** @type {?} */\n    var defaults = Chart.defaults;\n    /** @type {?} */\n    var valueOrDefault = helpers.valueOrDefault;\n    /**\n     * @param {?} labelOpts\n     * @param {?} fontSize\n     * @return {?}\n     */\n    function getBoxWidth(labelOpts, fontSize) {\n        return labelOpts.usePointStyle && labelOpts.boxWidth > fontSize ?\n            fontSize :\n            labelOpts.boxWidth;\n    }\n    /**\n     * @return {?}\n     */\n    function fit() {\n        /** @type {?} */\n        var me = this;\n        /** @type {?} */\n        var opts = me.options;\n        /** @type {?} */\n        var labelOpts = opts.labels;\n        /** @type {?} */\n        var display = opts.display;\n        /** @type {?} */\n        var ctx = me.ctx;\n        /** @type {?} */\n        var labelFont = helpers.options._parseFont(labelOpts);\n        /** @type {?} */\n        var fontSize = labelFont.size;\n        // Reset hit boxes\n        /** @type {?} */\n        var hitboxes = me.legendHitBoxes = [];\n        /** @type {?} */\n        var minSize = me.minSize;\n        /** @type {?} */\n        var isHorizontal = me.isHorizontal();\n        if (isHorizontal) {\n            minSize.width = me.maxWidth; // fill all the width\n            minSize.height = display ? 10 : 0;\n        }\n        else {\n            minSize.width = display ? 10 : 0;\n            minSize.height = me.maxHeight; // fill all the height\n        }\n        /** @type {?} */\n        var getMaxLineWidth = ( /**\n         * @param {?} textLines\n         * @return {?}\n         */function (textLines) {\n            return textLines.map(( /**\n             * @param {?} textLine\n             * @return {?}\n             */function (textLine) {\n                return ctx.measureText(textLine).width;\n            })).reduce(( /**\n             * @param {?} acc\n             * @param {?} v\n             * @return {?}\n             */function (acc, v) {\n                return v > acc ? v : acc;\n            }), 0);\n        });\n        // Increase sizes here\n        if (display) {\n            ctx.font = labelFont.string;\n            if (isHorizontal) {\n                // Labels\n                // Width of each line of legend boxes. Labels wrap onto multiple lines when there are too many to fit on one\n                /** @type {?} */\n                var lineWidths = me.lineWidths = [0];\n                /** @type {?} */\n                var lineHeights = me.lineHeights = [];\n                /** @type {?} */\n                var currentLineHeight = 0;\n                /** @type {?} */\n                var lineIndex = 0;\n                ctx.textAlign = 'left';\n                ctx.textBaseline = 'top';\n                helpers.each(me.legendItems, ( /**\n                 * @param {?} legendItem\n                 * @param {?} i\n                 * @return {?}\n                 */function (legendItem, i) {\n                    /** @type {?} */\n                    var width;\n                    /** @type {?} */\n                    var height;\n                    if (helpers.isArray(legendItem.text)) {\n                        width = getMaxLineWidth(legendItem.text);\n                        height = fontSize * legendItem.text.length + labelOpts.padding;\n                    }\n                    else {\n                        width = ctx.measureText(legendItem.text).width;\n                        height = fontSize + labelOpts.padding;\n                    }\n                    width += getBoxWidth(labelOpts, fontSize) + (fontSize / 2);\n                    if (lineWidths[lineWidths.length - 1] + width + 2 * labelOpts.padding > minSize.width) {\n                        lineHeights.push(currentLineHeight);\n                        currentLineHeight = 0;\n                        lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;\n                        lineIndex++;\n                    }\n                    legendItem.lineOrColumnIndex = lineIndex;\n                    if (height > currentLineHeight) {\n                        currentLineHeight = height;\n                    }\n                    // Store the hitbox width and height here. Final position will be updated in `draw`\n                    hitboxes[i] = {\n                        left: 0,\n                        top: 0,\n                        width: width,\n                        height: height,\n                    };\n                    lineWidths[lineWidths.length - 1] += width + labelOpts.padding;\n                }));\n                lineHeights.push(currentLineHeight);\n                minSize.height += lineHeights.reduce(( /**\n                 * @param {?} acc\n                 * @param {?} v\n                 * @return {?}\n                 */function (acc, v) {\n                    return acc + v;\n                }), 0);\n            }\n            else {\n                /** @type {?} */\n                var vPadding = labelOpts.padding;\n                /** @type {?} */\n                var columnWidths = me.columnWidths = [];\n                /** @type {?} */\n                var columnHeights = me.columnHeights = [];\n                /** @type {?} */\n                var totalWidth = labelOpts.padding;\n                /** @type {?} */\n                var currentColWidth = 0;\n                /** @type {?} */\n                var currentColHeight = 0;\n                /** @type {?} */\n                var columnIndex = 0;\n                helpers.each(me.legendItems, ( /**\n                 * @param {?} legendItem\n                 * @param {?} i\n                 * @return {?}\n                 */function (legendItem, i) {\n                    /** @type {?} */\n                    var itemWidth;\n                    /** @type {?} */\n                    var height;\n                    if (helpers.isArray(legendItem.text)) {\n                        itemWidth = getMaxLineWidth(legendItem.text);\n                        height = fontSize * legendItem.text.length;\n                    }\n                    else {\n                        itemWidth = ctx.measureText(legendItem.text).width;\n                        height = fontSize;\n                    }\n                    itemWidth += getBoxWidth(labelOpts, fontSize) + (fontSize / 2);\n                    // If too tall, go to new column\n                    if (currentColHeight + fontSize + 2 * vPadding > minSize.height) {\n                        totalWidth += currentColWidth + labelOpts.padding;\n                        columnWidths.push(currentColWidth); // previous column width\n                        columnHeights.push(currentColHeight);\n                        currentColWidth = 0;\n                        currentColHeight = 0;\n                        columnIndex++;\n                    }\n                    legendItem.lineOrColumnIndex = columnIndex;\n                    // Get max width\n                    currentColWidth = Math.max(currentColWidth, itemWidth);\n                    currentColHeight += height + vPadding;\n                    // Store the hitbox width and height here. Final position will be updated in `draw`\n                    hitboxes[i] = {\n                        left: 0,\n                        top: 0,\n                        width: itemWidth,\n                        height: height\n                    };\n                }));\n                totalWidth += currentColWidth;\n                columnWidths.push(currentColWidth);\n                columnHeights.push(currentColHeight);\n                minSize.width += totalWidth;\n            }\n        }\n        me.width = minSize.width;\n        me.height = minSize.height;\n    }\n    /**\n     * @return {?}\n     */\n    function draw() {\n        /** @type {?} */\n        var me = this;\n        /** @type {?} */\n        var opts = me.options;\n        /** @type {?} */\n        var labelOpts = opts.labels;\n        /** @type {?} */\n        var globalDefaults = defaults.global;\n        /** @type {?} */\n        var defaultColor = globalDefaults.defaultColor;\n        /** @type {?} */\n        var lineDefault = globalDefaults.elements.line;\n        /** @type {?} */\n        var legendHeight = me.height;\n        /** @type {?} */\n        var columnHeights = me.columnHeights;\n        /** @type {?} */\n        var columnWidths = me.columnWidths;\n        /** @type {?} */\n        var legendWidth = me.width;\n        /** @type {?} */\n        var lineWidths = me.lineWidths;\n        /** @type {?} */\n        var lineHeights = me.lineHeights;\n        if (opts.display) {\n            /** @type {?} */\n            var ctx = me.ctx;\n            /** @type {?} */\n            var fontColor = valueOrDefault(labelOpts.fontColor, globalDefaults.defaultFontColor);\n            /** @type {?} */\n            var labelFont = helpers.options._parseFont(labelOpts);\n            /** @type {?} */\n            var fontSize = labelFont.size;\n            /** @type {?} */\n            var cursor;\n            // Canvas setup\n            ctx.textAlign = 'left';\n            ctx.textBaseline = 'middle';\n            ctx.lineWidth = 0.5;\n            ctx.strokeStyle = fontColor; // for strikethrough effect\n            ctx.fillStyle = fontColor; // render in correct colour\n            ctx.font = labelFont.string;\n            /** @type {?} */\n            var boxWidth = getBoxWidth(labelOpts, fontSize);\n            /** @type {?} */\n            var hitboxes = me.legendHitBoxes;\n            // current position\n            /** @type {?} */\n            var drawLegendBox = ( /**\n             * @param {?} x\n             * @param {?} y\n             * @param {?} legendItem\n             * @return {?}\n             */function (x, y, legendItem) {\n                if (isNaN(boxWidth) || boxWidth <= 0) {\n                    return;\n                }\n                // Set the ctx for the box\n                ctx.save();\n                /** @type {?} */\n                var lineWidth = valueOrDefault(legendItem.lineWidth, lineDefault.borderWidth);\n                ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);\n                ctx.lineCap = valueOrDefault(legendItem.lineCap, lineDefault.borderCapStyle);\n                ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, lineDefault.borderDashOffset);\n                ctx.lineJoin = valueOrDefault(legendItem.lineJoin, lineDefault.borderJoinStyle);\n                ctx.lineWidth = lineWidth;\n                ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);\n                if (ctx.setLineDash) {\n                    // IE 9 and 10 do not support line dash\n                    ctx.setLineDash(valueOrDefault(legendItem.lineDash, lineDefault.borderDash));\n                }\n                if (opts.labels && opts.labels.usePointStyle) {\n                    // Recalculate x and y for drawPoint() because its expecting\n                    // x and y to be center of figure (instead of top left)\n                    /** @type {?} */\n                    var radius = boxWidth * Math.SQRT2 / 2;\n                    /** @type {?} */\n                    var centerX = x + boxWidth / 2;\n                    /** @type {?} */\n                    var centerY = y + fontSize / 2;\n                    // Draw pointStyle as legend symbol\n                    helpers.canvas.drawPoint(ctx, legendItem.pointStyle, radius, centerX, centerY);\n                }\n                else {\n                    // Draw box as legend symbol\n                    if (lineWidth !== 0) {\n                        ctx.strokeRect(x, y, boxWidth, fontSize);\n                    }\n                    ctx.fillRect(x, y, boxWidth, fontSize);\n                }\n                ctx.restore();\n            });\n            /** @type {?} */\n            var drawStrikeThrough = ( /**\n             * @param {?} x\n             * @param {?} y\n             * @param {?} w\n             * @return {?}\n             */function (x, y, w) {\n                ctx.beginPath();\n                ctx.lineWidth = 2;\n                ctx.moveTo(x, y);\n                ctx.lineTo(x + w, y);\n                ctx.stroke();\n            });\n            /** @type {?} */\n            var drawCrossOver = ( /**\n             * @param {?} x\n             * @param {?} y\n             * @param {?} w\n             * @param {?} h\n             * @return {?}\n             */function (x, y, w, h) {\n                ctx.beginPath();\n                ctx.lineWidth = 2;\n                ctx.moveTo(x, y);\n                ctx.lineTo(x + w, y + h);\n                ctx.moveTo(x, y + h);\n                ctx.lineTo(x + w, y);\n                ctx.stroke();\n            });\n            /** @type {?} */\n            var fillText = ( /**\n             * @param {?} x\n             * @param {?} y\n             * @param {?} legendItem\n             * @param {?} textWidth\n             * @return {?}\n             */function (x, y, legendItem, textWidth) {\n                /** @type {?} */\n                var halfFontSize = fontSize / 2;\n                /** @type {?} */\n                var xLeft = boxWidth + halfFontSize + x;\n                /** @type {?} */\n                var yMiddle = y + halfFontSize;\n                if (helpers.isArray(legendItem.text)) {\n                    helpers.each(legendItem.text, ( /**\n                     * @param {?} textLine\n                     * @param {?} index\n                     * @return {?}\n                     */function (textLine, index) {\n                        /** @type {?} */\n                        var lineOffset = index * fontSize;\n                        ctx.fillText(textLine, xLeft, yMiddle + lineOffset);\n                    }));\n                }\n                else {\n                    ctx.fillText(legendItem.text, xLeft, yMiddle);\n                }\n                if (legendItem.hidden) {\n                    if (helpers.isArray(legendItem.text)) {\n                        drawCrossOver(xLeft, yMiddle, textWidth, (legendItem.text.length - 1) * (fontSize - 1));\n                    }\n                    else {\n                        drawStrikeThrough(xLeft, yMiddle, textWidth);\n                    }\n                }\n            });\n            /** @type {?} */\n            var alignmentOffset = ( /**\n             * @param {?} dimension\n             * @param {?} blockSize\n             * @return {?}\n             */function (dimension, blockSize) {\n                switch (opts.align) {\n                    case 'start':\n                        return labelOpts.padding;\n                    case 'end':\n                        return dimension - blockSize;\n                    default: // center\n                        return (dimension - blockSize + labelOpts.padding) / 2;\n                }\n            });\n            // Horizontal\n            /** @type {?} */\n            var isHorizontal = me.isHorizontal();\n            if (isHorizontal) {\n                cursor = {\n                    x: me.left + alignmentOffset(legendWidth, lineWidths[0]),\n                    y: me.top + labelOpts.padding,\n                    line: 0\n                };\n            }\n            else {\n                cursor = {\n                    x: me.left + labelOpts.padding,\n                    y: me.top + alignmentOffset(legendHeight, columnHeights[0]),\n                    line: 0\n                };\n            }\n            helpers.each(me.legendItems, ( /**\n             * @param {?} legendItem\n             * @param {?} i\n             * @return {?}\n             */function (legendItem, i) {\n                /** @type {?} */\n                var textWidth;\n                /** @type {?} */\n                var height;\n                /** @type {?} */\n                var boxTopOffset;\n                if (legendItem.lineOrColumnIndex > cursor.line) {\n                    if (isHorizontal) {\n                        cursor.y += lineHeights[cursor.line];\n                        cursor.line = legendItem.lineOrColumnIndex;\n                        cursor.x = me.left + alignmentOffset(legendWidth, lineWidths[cursor.line]);\n                    }\n                    else {\n                        cursor.x += columnWidths[cursor.line] + labelOpts.padding;\n                        cursor.line = legendItem.lineOrColumnIndex;\n                        cursor.y = me.top + alignmentOffset(legendHeight, columnHeights[cursor.line]);\n                    }\n                }\n                if (helpers.isArray(legendItem.text)) {\n                    textWidth = legendItem.text.map(( /**\n                     * @param {?} textLine\n                     * @return {?}\n                     */function (textLine) {\n                        return ctx.measureText(textLine).width;\n                    })).reduce(( /**\n                     * @param {?} acc\n                     * @param {?} v\n                     * @return {?}\n                     */function (acc, v) {\n                        return v > acc ? v : acc;\n                    }), 0);\n                    boxTopOffset = fontSize / 2 * (legendItem.text.length - 1);\n                    height = fontSize * legendItem.text.length;\n                }\n                else {\n                    textWidth = ctx.measureText(legendItem.text).width;\n                    boxTopOffset = 0;\n                    height = fontSize;\n                }\n                /** @type {?} */\n                var width = boxWidth + (fontSize / 2) + textWidth;\n                /** @type {?} */\n                var x = cursor.x;\n                /** @type {?} */\n                var y = cursor.y;\n                /** @type {?} */\n                var topOffset = isHorizontal ? Math.trunc((lineHeights[cursor.line] - hitboxes[i].height) / 2) : 0;\n                drawLegendBox(x, y + boxTopOffset + topOffset, legendItem);\n                hitboxes[i].left = x;\n                hitboxes[i].top = y;\n                // Fill the actual label\n                fillText(x, y + topOffset, legendItem, textWidth);\n                if (isHorizontal) {\n                    cursor.x += width + labelOpts.padding;\n                }\n                else {\n                    cursor.y += height + labelOpts.padding;\n                }\n            }));\n        }\n    }\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n// tslint:disable:variable-name\n// tslint:disable:no-var-keyword\n// tslint:disable:prefer-const\n// tslint:disable:only-arrow-functions\n// tslint:disable:one-variable-per-declaration\n// tslint:disable:object-literal-shorthand\n// tslint:disable:space-before-function-paren\n/**\n * @return {?}\n */\nfunction monkeyPatchChartJsTooltip() {\n    if (typeof Chart === 'undefined') {\n        console.log('Chart not defined (guessing this is a universal build, and I don\\'t know why this happens -- Aviad)');\n        return;\n    }\n    Chart.Tooltip.prototype.drawBody = drawBody;\n    /** @type {?} */\n    var helpers = Chart.helpers;\n    /**\n     * @param {?} vm\n     * @param {?} align\n     * @return {?}\n     */\n    function getAlignedX(vm, align) {\n        return align === 'center'\n            ? vm.x + vm.width / 2\n            : align === 'right'\n                ? vm.x + vm.width - vm.xPadding\n                : vm.x + vm.xPadding;\n    }\n    /**\n     * @param {?} pt\n     * @param {?} vm\n     * @param {?} ctx\n     * @return {?}\n     */\n    function drawBody(pt, vm, ctx) {\n        /** @type {?} */\n        var bodyFontSize = vm.bodyFontSize;\n        /** @type {?} */\n        var bodySpacing = vm.bodySpacing;\n        /** @type {?} */\n        var bodyAlign = vm._bodyAlign;\n        /** @type {?} */\n        var body = vm.body;\n        /** @type {?} */\n        var drawColorBoxes = vm.displayColors;\n        /** @type {?} */\n        var labelColors = vm.labelColors;\n        /** @type {?} */\n        var xLinePadding = 0;\n        /** @type {?} */\n        var colorX = drawColorBoxes ? getAlignedX(vm, 'left') : 0;\n        /** @type {?} */\n        var textColor;\n        ctx.textAlign = bodyAlign;\n        ctx.textBaseline = 'top';\n        ctx.font = helpers.fontString(bodyFontSize, vm._bodyFontStyle, vm._bodyFontFamily);\n        pt.x = getAlignedX(vm, bodyAlign);\n        // Before Body\n        /** @type {?} */\n        var fillLineOfText = ( /**\n         * @param {?} line\n         * @return {?}\n         */function (line) {\n            ctx.fillText(line, pt.x + xLinePadding, pt.y);\n            pt.y += bodyFontSize + bodySpacing;\n        });\n        // Before body lines\n        ctx.fillStyle = vm.bodyFontColor;\n        helpers.each(vm.beforeBody, fillLineOfText);\n        xLinePadding = drawColorBoxes && bodyAlign !== 'right'\n            ? bodyAlign === 'center' ? (bodyFontSize / 2 + 1) : (bodyFontSize + 2)\n            : 0;\n        // Draw body lines now\n        helpers.each(body, ( /**\n         * @param {?} bodyItem\n         * @param {?} i\n         * @return {?}\n         */function (bodyItem, i) {\n            textColor = vm.labelTextColors[i];\n            ctx.fillStyle = textColor;\n            helpers.each(bodyItem.before, fillLineOfText);\n            // Draw Legend-like boxes if needed\n            if (drawColorBoxes) {\n                // Fill a white rect so that colours merge nicely if the opacity is < 1\n                ctx.fillStyle = vm.legendColorBackground;\n                ctx.fillRect(colorX, pt.y, bodyFontSize, bodyFontSize);\n                // Border\n                ctx.lineWidth = 1;\n                ctx.strokeStyle = labelColors[i].borderColor;\n                ctx.strokeRect(colorX, pt.y, bodyFontSize, bodyFontSize);\n                // Inner square\n                ctx.fillStyle = labelColors[i].backgroundColor;\n                ctx.fillRect(colorX + 1, pt.y + 1, bodyFontSize - 2, bodyFontSize - 2);\n                ctx.fillStyle = textColor;\n            }\n            helpers.each(bodyItem.lines, fillLineOfText);\n            helpers.each(bodyItem.after, fillLineOfText);\n        }));\n        // Reset back to 0 for after body\n        xLinePadding = 0;\n        // After body lines\n        helpers.each(vm.afterBody, fillLineOfText);\n        pt.y -= bodySpacing; // Remove last body spacing\n    }\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nexport { ChartsModule, BaseChartDirective, defaultColors, ThemeService, monkeyPatchChartJsLegend, monkeyPatchChartJsTooltip };\n//# sourceMappingURL=ng2-charts.js.map\n",null]}