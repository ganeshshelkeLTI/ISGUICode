/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { ApplicationRef, ComponentFactoryResolver, Injectable, Injector } from '@angular/core';
import * as i0 from "@angular/core";
var ComponentInjectService = /** @class */ (function () {
    function ComponentInjectService(applicationRef, componentFactoryResolver, injector) {
        this.applicationRef = applicationRef;
        this.componentFactoryResolver = componentFactoryResolver;
        this.injector = injector;
    }
    /**
     * @return {?}
     */
    ComponentInjectService.prototype.getRootViewContainer = /**
     * @return {?}
     */
    function () {
        if (this._container)
            return this._container;
        /** @type {?} */
        var rootComponents = this.applicationRef.components;
        if (rootComponents.length)
            return rootComponents[0];
        throw new Error('View Container not found! ngUpgrade needs to manually set this via setRootViewContainer.');
    };
    /**
     * @param {?} container
     * @return {?}
     */
    ComponentInjectService.prototype.setRootViewContainer = /**
     * @param {?} container
     * @return {?}
     */
    function (container) {
        this._container = container;
    };
    /**
     * @param {?} componentRef
     * @return {?}
     */
    ComponentInjectService.prototype.getComponentRootNode = /**
     * @param {?} componentRef
     * @return {?}
     */
    function (componentRef) {
        return /** @type {?} */ ((/** @type {?} */ (componentRef.hostView)).rootNodes[0]);
    };
    /**
     * @return {?}
     */
    ComponentInjectService.prototype.getRootViewContainerNode = /**
     * @return {?}
     */
    function () {
        return this.getComponentRootNode(this.getRootViewContainer());
    };
    /**
     * @param {?} component
     * @param {?} options
     * @return {?}
     */
    ComponentInjectService.prototype.projectComponentInputs = /**
     * @param {?} component
     * @param {?} options
     * @return {?}
     */
    function (component, options) {
        if (options) {
            /** @type {?} */
            var props = Object.getOwnPropertyNames(options);
            try {
                for (var props_1 = tslib_1.__values(props), props_1_1 = props_1.next(); !props_1_1.done; props_1_1 = props_1.next()) {
                    var prop = props_1_1.value;
                    component.instance[prop] = options[prop];
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (props_1_1 && !props_1_1.done && (_a = props_1.return)) _a.call(props_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
        return component;
        var e_1, _a;
    };
    /**
     * @template T
     * @param {?} componentClass
     * @param {?=} options
     * @param {?=} location
     * @return {?}
     */
    ComponentInjectService.prototype.appendComponentToBody = /**
     * @template T
     * @param {?} componentClass
     * @param {?=} options
     * @param {?=} location
     * @return {?}
     */
    function (componentClass, options, location) {
        if (options === void 0) { options = {}; }
        return this.appendComponent(componentClass, options, this.getRootViewContainerNode());
    };
    /**
     * @template T
     * @param {?} componentClass
     * @param {?=} options
     * @param {?=} location
     * @return {?}
     */
    ComponentInjectService.prototype.appendComponent = /**
     * @template T
     * @param {?} componentClass
     * @param {?=} options
     * @param {?=} location
     * @return {?}
     */
    function (componentClass, options, location) {
        if (options === void 0) { options = {}; }
        /** @type {?} */
        var componentFactory = this.componentFactoryResolver.resolveComponentFactory(componentClass);
        /** @type {?} */
        var componentRef = componentFactory.create(this.injector);
        /** @type {?} */
        var appRef = this.applicationRef;
        /** @type {?} */
        var componentRootNode = this.getComponentRootNode(componentRef);
        // project the options passed to the component instance
        this.projectComponentInputs(componentRef, options);
        // ApplicationRef's attachView and detachView methods are in Angular ^2.2.1 but not before.
        // The `else` clause here can be removed once 2.2.1 is released.
        if (appRef['attachView']) {
            appRef.attachView(componentRef.hostView);
            componentRef.onDestroy(function () {
                appRef.detachView(componentRef.hostView);
            });
        }
        else {
            /** @type {?} */
            var changeDetectorRef_1 = componentRef.changeDetectorRef;
            appRef.registerChangeDetector(changeDetectorRef_1);
            componentRef.onDestroy(function () {
                appRef.unregisterChangeDetector(changeDetectorRef_1);
                // Normally the ViewContainer will remove the component's nodes from the DOM.
                // Without a ViewContainer, we need to manually remove the nodes.
                if (componentRootNode.parentNode) {
                    componentRootNode.parentNode.removeChild(componentRootNode);
                }
            });
        }
        location.appendChild(componentRootNode);
        return componentRef;
    };
    /**
     * @param {?} compRef
     * @return {?}
     */
    ComponentInjectService.prototype.destroyComponent = /**
     * @param {?} compRef
     * @return {?}
     */
    function (compRef) {
        this.applicationRef.detachView(compRef.hostView);
        compRef.destroy();
    };
    ComponentInjectService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] },
    ];
    /** @nocollapse */
    ComponentInjectService.ctorParameters = function () { return [
        { type: ApplicationRef },
        { type: ComponentFactoryResolver },
        { type: Injector }
    ]; };
    /** @nocollapse */ ComponentInjectService.ngInjectableDef = i0.defineInjectable({ factory: function ComponentInjectService_Factory() { return new ComponentInjectService(i0.inject(i0.ApplicationRef), i0.inject(i0.ComponentFactoryResolver), i0.inject(i0.INJECTOR)); }, token: ComponentInjectService, providedIn: "root" });
    return ComponentInjectService;
}());
export { ComponentInjectService };
if (false) {
    /** @type {?} */
    ComponentInjectService.prototype._container;
    /** @type {?} */
    ComponentInjectService.prototype.applicationRef;
    /** @type {?} */
    ComponentInjectService.prototype.componentFactoryResolver;
    /** @type {?} */
    ComponentInjectService.prototype.injector;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29tcG9uZW50LWluamVjdC5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vbmc2LW5vdGlmeS1wb3B1cC8iLCJzb3VyY2VzIjpbImxpYi9zZXJ2aWNlcy9jb21wb25lbnQtaW5qZWN0LnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxPQUFPLEVBQ0wsY0FBYyxFQUNkLHdCQUF3QixFQUd4QixVQUFVLEVBQ1YsUUFBUSxFQUVULE1BQU0sZUFBZSxDQUFDOzs7SUFRckIsZ0NBQ1UsZ0JBQ0EsMEJBQ0E7UUFGQSxtQkFBYyxHQUFkLGNBQWM7UUFDZCw2QkFBd0IsR0FBeEIsd0JBQXdCO1FBQ3hCLGFBQVEsR0FBUixRQUFRO0tBRWpCOzs7O0lBRUQscURBQW9COzs7SUFBcEI7UUFDRSxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDO1lBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUM7O1FBRTVDLElBQU0sY0FBYyxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsVUFBVSxDQUFDO1FBQ3RELEVBQUUsQ0FBQyxDQUFDLGNBQWMsQ0FBQyxNQUFNLENBQUM7WUFBQyxNQUFNLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBRXBELE1BQU0sSUFBSSxLQUFLLENBQUMsMEZBQTBGLENBQUMsQ0FBQztLQUM3Rzs7Ozs7SUFFRCxxREFBb0I7Ozs7SUFBcEIsVUFBcUIsU0FBNEI7UUFDL0MsSUFBSSxDQUFDLFVBQVUsR0FBRyxTQUFTLENBQUM7S0FDN0I7Ozs7O0lBRUQscURBQW9COzs7O0lBQXBCLFVBQXFCLFlBQStCO1FBQ2xELE1BQU0sbUJBQUMsbUJBQUMsWUFBWSxDQUFDLFFBQWdDLEVBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFnQixFQUFDO0tBQ3BGOzs7O0lBRUQseURBQXdCOzs7SUFBeEI7UUFDRSxNQUFNLENBQUMsSUFBSSxDQUFDLG9CQUFvQixDQUFDLElBQUksQ0FBQyxvQkFBb0IsRUFB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dCB7XG4gIEFwcGxpY2F0aW9uUmVmLFxuICBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsXG4gIENvbXBvbmVudFJlZixcbiAgRW1iZWRkZWRWaWV3UmVmLFxuICBJbmplY3RhYmxlLFxuICBJbmplY3RvcixcbiAgVHlwZVxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQEluamVjdGFibGUoe1xuICBwcm92aWRlZEluOiAncm9vdCdcbn0pXG5leHBvcnQgY2xhc3MgQ29tcG9uZW50SW5qZWN0U2VydmljZSB7XG4gIHByaXZhdGUgX2NvbnRhaW5lcjogQ29tcG9uZW50UmVmPGFueT47XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBhcHBsaWNhdGlvblJlZjogQXBwbGljYXRpb25SZWYsXG4gICAgcHJpdmF0ZSBjb21wb25lbnRGYWN0b3J5UmVzb2x2ZXI6IENvbXBvbmVudEZhY3RvcnlSZXNvbHZlcixcbiAgICBwcml2YXRlIGluamVjdG9yOiBJbmplY3RvclxuICApIHtcbiAgfVxuXG4gIGdldFJvb3RWaWV3Q29udGFpbmVyKCk6IENvbXBvbmVudFJlZjxhbnk+IHtcbiAgICBpZiAodGhpcy5fY29udGFpbmVyKSByZXR1cm4gdGhpcy5fY29udGFpbmVyO1xuXG4gICAgY29uc3Qgcm9vdENvbXBvbmVudHMgPSB0aGlzLmFwcGxpY2F0aW9uUmVmLmNvbXBvbmVudHM7XG4gICAgaWYgKHJvb3RDb21wb25lbnRzLmxlbmd0aCkgcmV0dXJuIHJvb3RDb21wb25lbnRzWzBdO1xuXG4gICAgdGhyb3cgbmV3IEVycm9yKCdWaWV3IENvbnRhaW5lciBub3QgZm91bmQhIG5nVXBncmFkZSBuZWVkcyB0byBtYW51YWxseSBzZXQgdGhpcyB2aWEgc2V0Um9vdFZpZXdDb250YWluZXIuJyk7XG4gIH1cblxuICBzZXRSb290Vmlld0NvbnRhaW5lcihjb250YWluZXI6IENvbXBvbmVudFJlZjxhbnk+KTogdm9pZCB7XG4gICAgdGhpcy5fY29udGFpbmVyID0gY29udGFpbmVyO1xuICB9XG5cbiAgZ2V0Q29tcG9uZW50Um9vdE5vZGUoY29tcG9uZW50UmVmOiBDb21wb25lbnRSZWY8YW55Pik6IEhUTUxFbGVtZW50IHtcbiAgICByZXR1cm4gKGNvbXBvbmVudFJlZi5ob3N0VmlldyBhcyBFbWJlZGRlZFZpZXdSZWY8YW55Pikucm9vdE5vZGVzWzBdIGFzIEhUTUxFbGVtZW50O1xuICB9XG5cbiAgZ2V0Um9vdFZpZXdDb250YWluZXJOb2RlKCk6IEhUTUxFbGVtZW50IHtcbiAgICByZXR1cm4gdGhpcy5nZXRDb21wb25lbnRSb290Tm9kZSh0aGlzLmdldFJvb3RWaWV3Q29udGFpbmVyKCkpO1xuICB9XG5cbiAgcHJvamVjdENvbXBvbmVudElucHV0cyhjb21wb25lbnQ6IENvbXBvbmVudFJlZjxhbnk+LCBvcHRpb25zOiBhbnkpOiBDb21wb25lbnRSZWY8YW55PiB7XG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgIGNvbnN0IHByb3BzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob3B0aW9ucyk7XG4gICAgICBmb3IgKGNvbnN0IHByb3Agb2YgcHJvcHMpIHtcbiAgICAgICAgY29tcG9uZW50Lmluc3RhbmNlW3Byb3BdID0gb3B0aW9uc1twcm9wXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY29tcG9uZW50O1xuICB9XG5cbiAgYXBwZW5kQ29tcG9uZW50VG9Cb2R5PFQ+KFxuICAgIGNvbXBvbmVudENsYXNzOiBUeXBlPFQ+LFxuICAgIG9wdGlvbnM6IGFueSA9IHt9LFxuICAgIGxvY2F0aW9uOiBFbGVtZW50XG4gICk6IENvbXBvbmVudFJlZjxhbnk+IHtcbiAgICByZXR1cm4gdGhpcy5hcHBlbmRDb21wb25lbnQoY29tcG9uZW50Q2xhc3MsIG9wdGlvbnMsIHRoaXMuZ2V0Um9vdFZpZXdDb250YWluZXJOb2RlKCkpXG4gIH1cblxuICBhcHBlbmRDb21wb25lbnQ8VD4oXG4gICAgY29tcG9uZW50Q2xhc3M6IFR5cGU8VD4sXG4gICAgb3B0aW9uczogYW55ID0ge30sXG4gICAgbG9jYXRpb246IEVsZW1lbnRcbiAgKTogQ29tcG9uZW50UmVmPGFueT4ge1xuXG4gICAgbGV0IGNvbXBvbmVudEZhY3RvcnkgPSB0aGlzLmNvbXBvbmVudEZhY3RvcnlSZXNvbHZlci5yZXNvbHZlQ29tcG9uZW50RmFjdG9yeShjb21wb25lbnRDbGFzcyk7XG4gICAgbGV0IGNvbXBvbmVudFJlZiA9IGNvbXBvbmVudEZhY3RvcnkuY3JlYXRlKHRoaXMuaW5qZWN0b3IpO1xuICAgIGxldCBhcHBSZWY6IGFueSA9IHRoaXMuYXBwbGljYXRpb25SZWY7XG4gICAgbGV0IGNvbXBvbmVudFJvb3ROb2RlID0gdGhpcy5nZXRDb21wb25lbnRSb290Tm9kZShjb21wb25lbnRSZWYpO1xuXG4gICAgLy8gcHJvamVjdCB0aGUgb3B0aW9ucyBwYXNzZWQgdG8gdGhlIGNvbXBvbmVudCBpbnN0YW5jZVxuICAgIHRoaXMucHJvamVjdENvbXBvbmVudElucHV0cyhjb21wb25lbnRSZWYsIG9wdGlvbnMpO1xuXG4gICAgLy8gQXBwbGljYXRpb25SZWYncyBhdHRhY2hWaWV3IGFuZCBkZXRhY2hWaWV3IG1ldGhvZHMgYXJlIGluIEFuZ3VsYXIgXjIuMi4xIGJ1dCBub3QgYmVmb3JlLlxuICAgIC8vIFRoZSBgZWxzZWAgY2xhdXNlIGhlcmUgY2FuIGJlIHJlbW92ZWQgb25jZSAyLjIuMSBpcyByZWxlYXNlZC5cbiAgICBpZiAoYXBwUmVmWydhdHRhY2hWaWV3J10pIHtcbiAgICAgIGFwcFJlZi5hdHRhY2hWaWV3KGNvbXBvbmVudFJlZi5ob3N0Vmlldyk7XG5cbiAgICAgIGNvbXBvbmVudFJlZi5vbkRlc3Ryb3koKCkgPT4ge1xuICAgICAgICBhcHBSZWYuZGV0YWNoVmlldyhjb21wb25lbnRSZWYuaG9zdFZpZXcpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFdoZW4gY3JlYXRpbmcgYSBjb21wb25lbnQgb3V0c2lkZSBvZiBhIFZpZXdDb250YWluZXIsIHdlIG5lZWQgdG8gbWFudWFsbHkgcmVnaXN0ZXJcbiAgICAgIC8vIGl0cyBDaGFuZ2VEZXRlY3RvciB3aXRoIHRoZSBhcHBsaWNhdGlvbi4gVGhpcyBBUEkgaXMgdW5mb3J0dW5hdGVseSBub3QgcHVibGlzaGVkXG4gICAgICAvLyBpbiBBbmd1bGFyIDw9IDIuMi4wLiBUaGUgY2hhbmdlIGRldGVjdG9yIG11c3QgYWxzbyBiZSBkZXJlZ2lzdGVyZWQgd2hlbiB0aGUgY29tcG9uZW50XG4gICAgICAvLyBpcyBkZXN0cm95ZWQgdG8gcHJldmVudCBtZW1vcnkgbGVha3MuXG4gICAgICBsZXQgY2hhbmdlRGV0ZWN0b3JSZWYgPSBjb21wb25lbnRSZWYuY2hhbmdlRGV0ZWN0b3JSZWY7XG4gICAgICBhcHBSZWYucmVnaXN0ZXJDaGFuZ2VEZXRlY3RvcihjaGFuZ2VEZXRlY3RvclJlZik7XG5cbiAgICAgIGNvbXBvbmVudFJlZi5vbkRlc3Ryb3koKCkgPT4ge1xuICAgICAgICBhcHBSZWYudW5yZWdpc3RlckNoYW5nZURldGVjdG9yKGNoYW5nZURldGVjdG9yUmVmKTtcblxuICAgICAgICAvLyBOb3JtYWxseSB0aGUgVmlld0NvbnRhaW5lciB3aWxsIHJlbW92ZSB0aGUgY29tcG9uZW50J3Mgbm9kZXMgZnJvbSB0aGUgRE9NLlxuICAgICAgICAvLyBXaXRob3V0IGEgVmlld0NvbnRhaW5lciwgd2UgbmVlZCB0byBtYW51YWxseSByZW1vdmUgdGhlIG5vZGVzLlxuICAgICAgICBpZiAoY29tcG9uZW50Um9vdE5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICAgIGNvbXBvbmVudFJvb3ROb2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY29tcG9uZW50Um9vdE5vZGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBsb2NhdGlvbi5hcHBlbmRDaGlsZChjb21wb25lbnRSb290Tm9kZSk7XG5cbiAgICByZXR1cm4gY29tcG9uZW50UmVmO1xuICB9XG5cbiAgZGVzdHJveUNvbXBvbmVudChjb21wUmVmOiBDb21wb25lbnRSZWY8YW55Pik6IHZvaWQge1xuICAgIHRoaXMuYXBwbGljYXRpb25SZWYuZGV0YWNoVmlldyhjb21wUmVmLmhvc3RWaWV3KTtcbiAgICBjb21wUmVmLmRlc3Ryb3koKTtcbiAgfVxufVxuIl19